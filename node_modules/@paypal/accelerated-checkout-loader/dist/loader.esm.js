/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */


function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var dist = {};

var scriptPromiseCache = {};
function loadScript$1(options) {
    var scriptLoadPromise;
    var stringifiedOptions = JSON.stringify(options);
    if (!options.forceScriptReload) {
        scriptLoadPromise = scriptPromiseCache[stringifiedOptions];
        if (scriptLoadPromise) {
            return scriptLoadPromise;
        }
    }
    var script = document.createElement("script");
    var attrs = options.dataAttributes || {};
    var container = options.container || document.head;
    script.src = options.src;
    script.id = options.id || "";
    script.async = true;
    if (options.type) {
        script.setAttribute("type", "".concat(options.type));
    }
    if (options.crossorigin) {
        script.setAttribute("crossorigin", "".concat(options.crossorigin));
    }
    Object.keys(attrs).forEach(function (key) {
        script.setAttribute("data-".concat(key), "".concat(attrs[key]));
    });
    scriptLoadPromise = new Promise(function (resolve, reject) {
        script.addEventListener("load", function () {
            resolve(script);
        });
        script.addEventListener("error", function () {
            reject(new Error("".concat(options.src, " failed to load.")));
        });
        script.addEventListener("abort", function () {
            reject(new Error("".concat(options.src, " has aborted.")));
        });
        container.appendChild(script);
    });
    scriptPromiseCache[stringifiedOptions] = scriptLoadPromise;
    return scriptLoadPromise;
}
loadScript$1.clearCache = function () {
    scriptPromiseCache = {};
};
var loadScript_1$1 = loadScript$1;

var loadStylesheet$1 = function loadStylesheet(options) {
    var stylesheet = document.querySelector("link[href=\"".concat(options.href, "\"]"));
    if (stylesheet) {
        return Promise.resolve(stylesheet);
    }
    stylesheet = document.createElement("link");
    var container = options.container || document.head;
    stylesheet.setAttribute("rel", "stylesheet");
    stylesheet.setAttribute("type", "text/css");
    stylesheet.setAttribute("href", options.href);
    stylesheet.setAttribute("id", options.id);
    if (container.firstChild) {
        container.insertBefore(stylesheet, container.firstChild);
    }
    else {
        container.appendChild(stylesheet);
    }
    return Promise.resolve(stylesheet);
};

Object.defineProperty(dist, "__esModule", { value: true });
dist.loadStylesheet = loadScript_1 = dist.loadScript = void 0;
var loadScript = loadScript_1$1;
var loadScript_1 = dist.loadScript = loadScript;
var loadStylesheet = loadStylesheet$1;
dist.loadStylesheet = loadStylesheet;

var CDNX_PROD = "https://www.paypalobjects.com";
var ASSET_NAME = {
    minified: "axo.min",
    unminified: "axo",
};
var FL_NAMESPACE = "fastlane";
var ASSET_PATH = "connect-boba";
var LOCALE_PATH = "".concat(ASSET_PATH, "/locales/");
var constants = {
    AXO_ASSET_NAME: ASSET_NAME,
    AXO_ASSET_PATH: ASSET_PATH,
    LOCALE_PATH: LOCALE_PATH,
    CDNX_PROD: CDNX_PROD,
};

var AxoSupportedPlatforms = {
    BT: "BT",
    PPCP: "PPCP",
};

/**
 * Checks if the current environment is an AMD environment.
 *
 * @returns {boolean} True if the environment is AMD, false otherwise.
 */
function isAmdEnv() {
    return typeof window.define === "function" && !!window.define.amd;
}
/**
 * Checks if the current environment is a RequireJS environment.
 *
 * @returns {boolean} True if the environment is RequireJS, false otherwise.
 */
function isRequireJsEnv() {
    return (isAmdEnv() &&
        typeof window.requirejs === "function" &&
        typeof window.requirejs.config === "function");
}

/**
 * Safely loads BT modules by checking if the module already exists and verifying if versions mismatch
 *
 * @param loadConfig <BtModuleLoadConfig> Configuration of BT Module to load
 * @param version <string> version that should be passed from the client getVersion
 * @returns Promise<HTMLScriptElement>
 * @returns Promise<true> when BT module with same version already exists
 * @returns Promise.reject(err) when BT module already exists but versions mismatch or empty version passed in
 */
function safeLoadBtModule(loadConfig, version, minified) {
    var _a, _b;
    if (minified === void 0) { minified = true; }
    return __awaiter(this, void 0, void 0, function () {
        var bt, existingVersion;
        return __generator(this, function (_c) {
            bt = getBraintree();
            if (bt && bt[loadConfig.module]) {
                if (version && ((_a = bt[loadConfig.module]) === null || _a === void 0 ? void 0 : _a.VERSION) !== version) {
                    existingVersion = (_b = bt[loadConfig.module]) === null || _b === void 0 ? void 0 : _b.VERSION;
                    throw new Error("".concat(loadConfig.module, " already loaded with version ").concat(existingVersion, " cannot load version ").concat(version));
                }
                else {
                    return [2 /*return*/, true];
                }
            }
            if (!version) {
                throw new Error("Attempted to load ".concat(loadConfig.module, " without specifying version"));
            }
            return [2 /*return*/, loadBtModule(loadConfig, version, minified)];
        });
    });
}
/**
 * Reads the version and to load the correct version of Bt module
 *
 * @param loadConfig <BtModuleLoadConfig> Configuration of BT Module to load
 * @param version <string> Bt module version
 * @returns Promise<HTMLScriptElement> or
 */
function loadBtModule(loadConfig, version, minified) {
    if (minified === void 0) { minified = true; }
    if (isAmdEnv()) {
        var module_1 = minified
            ? loadConfig.amdModule.minified
            : loadConfig.amdModule.unminified;
        return new Promise(function (resolve, reject) {
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            window.require([module_1], resolve, reject);
        });
    }
    var script = minified
        ? loadConfig.script.minified
        : loadConfig.script.unminified;
    return loadScript_1({
        id: "".concat(loadConfig.id, "-").concat(version),
        src: "https://js.braintreegateway.com/web/".concat(version, "/js/").concat(script),
    });
}
/**
 * Looks for the Braintree web sdk on the window object
 *
 * @returns Braintree web sdk
 */
function getBraintree() {
    return window === null || window === void 0 ? void 0 : window.braintree;
}

var _a, _b;
/**
 * Maps to the BT module namespace created on the window.braintree object
 */
var BtModule = {
    Client: "client",
    HostedCardFields: "hostedFields",
};
var BT_NAMESPACE = "braintree";
var BT_ASSET_NAME = (_a = {},
    _a[BtModule.Client] = "client",
    _a[BtModule.HostedCardFields] = "hosted-fields",
    _a);
var btModulesLoadConfig = (_b = {},
    _b[BtModule.Client] = {
        id: "client",
        module: BtModule.Client,
        amdModule: {
            unminified: "".concat(BT_NAMESPACE, "/").concat(BT_ASSET_NAME[BtModule.Client]),
            minified: "".concat(BT_NAMESPACE, "/").concat(BT_ASSET_NAME[BtModule.Client], ".min"),
        },
        script: {
            unminified: "".concat(BT_ASSET_NAME[BtModule.Client], ".js"),
            minified: "".concat(BT_ASSET_NAME[BtModule.Client], ".min.js"),
        },
    },
    _b[BtModule.HostedCardFields] = {
        id: "hcf",
        module: BtModule.HostedCardFields,
        amdModule: {
            unminified: "".concat(BT_NAMESPACE, "/").concat(BT_ASSET_NAME[BtModule.HostedCardFields]),
            minified: "".concat(BT_NAMESPACE, "/").concat(BT_ASSET_NAME[BtModule.HostedCardFields], ".min"),
        },
        script: {
            unminified: "".concat(BT_ASSET_NAME[BtModule.HostedCardFields], ".js"),
            minified: "".concat(BT_ASSET_NAME[BtModule.HostedCardFields], ".min.js"),
        },
    },
    _b);

/**
 * Loads accelerated checkout components.
 * @param options object with a minified parameter to determine if the script that is loaded should be minified or not (defaults to true if)
 * @returns an object with metadata with a localeUrl parameter to be read by AXO SDK
 */
function loadAxo(options) {
    return __awaiter(this, void 0, void 0, function () {
        var btSdkVersion, minified, assetUrl, localeUrl;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    performance.mark("pp_axo_sdk_init_invoked");
                    btSdkVersion = options.btSdkVersion, minified = options.minified;
                    assetUrl = getAssetsUrl(options);
                    localeUrl = getLocaleUrl(options);
                    if (!(options.platform === AxoSupportedPlatforms.BT)) return [3 /*break*/, 2];
                    return [4 /*yield*/, Promise.all([
                            safeLoadBtModule(btModulesLoadConfig.hostedFields, btSdkVersion, minified),
                            loadAXOScript(assetUrl, minified),
                        ])];
                case 1:
                    _a.sent();
                    return [3 /*break*/, 5];
                case 2:
                    if (!(options.platform === AxoSupportedPlatforms.PPCP)) return [3 /*break*/, 4];
                    return [4 /*yield*/, Promise.all([
                            safeLoadBtModule(btModulesLoadConfig.client, btSdkVersion, minified),
                            safeLoadBtModule(btModulesLoadConfig.hostedFields, btSdkVersion, minified),
                            loadAXOScript(assetUrl, minified),
                        ])];
                case 3:
                    _a.sent();
                    return [3 /*break*/, 5];
                case 4: throw new Error("unsupported axo platform");
                case 5: return [2 /*return*/, { metadata: { localeUrl: localeUrl } }];
            }
        });
    });
}
/**
 * Reads the url and to load the axo bundle script
 * @param url (Required) string url for the correct axo asset
 * @returns Promise<HTMLScriptElement>
 */
function loadAXOScript(url, minified) {
    var _a;
    if (minified === void 0) { minified = true; }
    if (isAmdEnv()) {
        // AMD environment
        if (isRequireJsEnv()) {
            // Let's configure RequireJS
            requirejs.config({
                paths: (_a = {},
                    _a[FL_NAMESPACE] = url,
                    _a),
            });
        }
        var moduleName_1 = "".concat(FL_NAMESPACE, "/").concat(minified
            ? constants.AXO_ASSET_NAME.minified
            : constants.AXO_ASSET_NAME.unminified);
        return new Promise(function (resolve, reject) {
            window.require([moduleName_1], resolve, reject);
        });
    }
    // Not an AMD environment
    return loadScript_1({
        id: "axo-id",
        src: url,
        forceScriptReload: true,
    });
}
/**
 * Prepends the domain to the asset url
 * @param options object with assetUrl and bundleid parameters to determine which URL to return
 * @returns full domain and assets URL as string
 */
function generateAssetUrl(_a) {
    var assetUrl = _a.assetUrl, bundleId = _a.bundleId;
    return bundleId
        ? "https://cdn-".concat(bundleId, ".static.engineering.dev.paypalinc.com/").concat(assetUrl)
        : "".concat(constants.CDNX_PROD, "/").concat(assetUrl);
}
/**
 * Retrieves either the minified or unminified assets URL as specified
 * @param options (Optional) object with a minified and metadata with bundleIdOverride parameters to determine which URL to return
 * @returns assets URL as string
 */
function getAssetsUrl(options) {
    var _a;
    var assetName = (options === null || options === void 0 ? void 0 : options.minified) !== false
        ? constants.AXO_ASSET_NAME.minified
        : constants.AXO_ASSET_NAME.unminified;
    var assetUrl = isAmdEnv()
        ? constants.AXO_ASSET_PATH
        : "".concat(constants.AXO_ASSET_PATH, "/").concat(assetName, ".js");
    return generateAssetUrl({
        assetUrl: assetUrl,
        bundleId: (_a = options === null || options === void 0 ? void 0 : options.metadata) === null || _a === void 0 ? void 0 : _a.bundleIdOverride,
    });
}
/**
 * Retrieves the Locales URL, the path to our language files
 * @param options (Optional) object with a minified and metadata with bundleIdOverride parameters to determine which URL to return
 * @returns locale URL as string
 */
function getLocaleUrl(options) {
    var _a;
    return generateAssetUrl({
        assetUrl: constants.LOCALE_PATH,
        bundleId: (_a = options === null || options === void 0 ? void 0 : options.metadata) === null || _a === void 0 ? void 0 : _a.bundleIdOverride,
    });
}

export { constants, loadAxo };
