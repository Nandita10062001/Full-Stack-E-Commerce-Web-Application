(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.braintree || (g.braintree = {})).unionpay = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(_dereq_,module,exports){
"use strict";
var scriptPromiseCache = {};
function loadScript(options) {
    var scriptLoadPromise;
    var stringifiedOptions = JSON.stringify(options);
    if (!options.forceScriptReload) {
        scriptLoadPromise = scriptPromiseCache[stringifiedOptions];
        if (scriptLoadPromise) {
            return scriptLoadPromise;
        }
    }
    var script = document.createElement("script");
    var attrs = options.dataAttributes || {};
    var container = options.container || document.head;
    script.src = options.src;
    script.id = options.id || "";
    script.async = true;
    if (options.type) {
        script.setAttribute("type", "".concat(options.type));
    }
    if (options.crossorigin) {
        script.setAttribute("crossorigin", "".concat(options.crossorigin));
    }
    Object.keys(attrs).forEach(function (key) {
        script.setAttribute("data-".concat(key), "".concat(attrs[key]));
    });
    scriptLoadPromise = new Promise(function (resolve, reject) {
        script.addEventListener("load", function () {
            resolve(script);
        });
        script.addEventListener("error", function () {
            reject(new Error("".concat(options.src, " failed to load.")));
        });
        script.addEventListener("abort", function () {
            reject(new Error("".concat(options.src, " has aborted.")));
        });
        container.appendChild(script);
    });
    scriptPromiseCache[stringifiedOptions] = scriptLoadPromise;
    return scriptLoadPromise;
}
loadScript.clearCache = function () {
    scriptPromiseCache = {};
};
module.exports = loadScript;

},{}],2:[function(_dereq_,module,exports){
module.exports = _dereq_("./dist/load-script");

},{"./dist/load-script":1}],3:[function(_dereq_,module,exports){
"use strict";
var set_attributes_1 = _dereq_("./lib/set-attributes");
var default_attributes_1 = _dereq_("./lib/default-attributes");
var assign_1 = _dereq_("./lib/assign");
module.exports = function createFrame(options) {
    if (options === void 0) { options = {}; }
    var iframe = document.createElement("iframe");
    var config = (0, assign_1.assign)({}, default_attributes_1.defaultAttributes, options);
    if (config.style && typeof config.style !== "string") {
        (0, assign_1.assign)(iframe.style, config.style);
        delete config.style;
    }
    (0, set_attributes_1.setAttributes)(iframe, config);
    if (!iframe.getAttribute("id")) {
        iframe.id = iframe.name;
    }
    return iframe;
};

},{"./lib/assign":4,"./lib/default-attributes":5,"./lib/set-attributes":6}],4:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assign = void 0;
function assign(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
target) {
    var objs = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        objs[_i - 1] = arguments[_i];
    }
    objs.forEach(function (obj) {
        if (typeof obj !== "object") {
            return;
        }
        Object.keys(obj).forEach(function (key) {
            target[key] = obj[key];
        });
    });
    return target;
}
exports.assign = assign;

},{}],5:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultAttributes = void 0;
exports.defaultAttributes = {
    src: "about:blank",
    frameBorder: 0,
    allowtransparency: true,
    scrolling: "no",
};

},{}],6:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setAttributes = void 0;
function setAttributes(element, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
attributes) {
    for (var key in attributes) {
        if (attributes.hasOwnProperty(key)) {
            var value = attributes[key];
            if (value == null) {
                element.removeAttribute(key);
            }
            else {
                element.setAttribute(key, value);
            }
        }
    }
}
exports.setAttributes = setAttributes;

},{}],7:[function(_dereq_,module,exports){
"use strict";

function uuid() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
    var r = (Math.random() * 16) | 0;
    var v = c === "x" ? r : (r & 0x3) | 0x8;

    return v.toString(16);
  });
}

module.exports = uuid;

},{}],8:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function deferred(fn) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        setTimeout(function () {
            try {
                fn.apply(void 0, args);
            }
            catch (err) {
                /* eslint-disable no-console */
                console.log("Error in callback function");
                console.log(err);
                /* eslint-enable no-console */
            }
        }, 1);
    };
}
exports.deferred = deferred;

},{}],9:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function once(fn) {
    var called = false;
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (!called) {
            called = true;
            fn.apply(void 0, args);
        }
    };
}
exports.once = once;

},{}],10:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable consistent-return */
function promiseOrCallback(promise, callback) {
    if (!callback) {
        return promise;
    }
    promise.then(function (data) { return callback(null, data); }).catch(function (err) { return callback(err); });
}
exports.promiseOrCallback = promiseOrCallback;

},{}],11:[function(_dereq_,module,exports){
"use strict";
var deferred_1 = _dereq_("./lib/deferred");
var once_1 = _dereq_("./lib/once");
var promise_or_callback_1 = _dereq_("./lib/promise-or-callback");
function wrapPromise(fn) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var callback;
        var lastArg = args[args.length - 1];
        if (typeof lastArg === "function") {
            callback = args.pop();
            callback = once_1.once(deferred_1.deferred(callback));
        }
        // I know, I know, this looks bad. But it's a quirk of the library that
        // we need to allow passing the this context to the original function
        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
        // @ts-ignore: this has an implicit any
        return promise_or_callback_1.promiseOrCallback(fn.apply(this, args), callback); // eslint-disable-line no-invalid-this
    };
}
wrapPromise.wrapPrototype = function (target, options) {
    if (options === void 0) { options = {}; }
    var ignoreMethods = options.ignoreMethods || [];
    var includePrivateMethods = options.transformPrivateMethods === true;
    var methods = Object.getOwnPropertyNames(target.prototype).filter(function (method) {
        var isNotPrivateMethod;
        var isNonConstructorFunction = method !== "constructor" &&
            typeof target.prototype[method] === "function";
        var isNotAnIgnoredMethod = ignoreMethods.indexOf(method) === -1;
        if (includePrivateMethods) {
            isNotPrivateMethod = true;
        }
        else {
            isNotPrivateMethod = method.charAt(0) !== "_";
        }
        return (isNonConstructorFunction && isNotPrivateMethod && isNotAnIgnoredMethod);
    });
    methods.forEach(function (method) {
        var original = target.prototype[method];
        target.prototype[method] = wrapPromise(original);
    });
    return target;
};
module.exports = wrapPromise;

},{"./lib/deferred":8,"./lib/once":9,"./lib/promise-or-callback":10}],12:[function(_dereq_,module,exports){
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.loadAxo = {}));
})(this, (function (exports) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */


    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    var dist = {};

    var scriptPromiseCache = {};
    function loadScript$1(options) {
        var scriptLoadPromise;
        var stringifiedOptions = JSON.stringify(options);
        if (!options.forceScriptReload) {
            scriptLoadPromise = scriptPromiseCache[stringifiedOptions];
            if (scriptLoadPromise) {
                return scriptLoadPromise;
            }
        }
        var script = document.createElement("script");
        var attrs = options.dataAttributes || {};
        var container = options.container || document.head;
        script.src = options.src;
        script.id = options.id || "";
        script.async = true;
        if (options.type) {
            script.setAttribute("type", "".concat(options.type));
        }
        if (options.crossorigin) {
            script.setAttribute("crossorigin", "".concat(options.crossorigin));
        }
        Object.keys(attrs).forEach(function (key) {
            script.setAttribute("data-".concat(key), "".concat(attrs[key]));
        });
        scriptLoadPromise = new Promise(function (resolve, reject) {
            script.addEventListener("load", function () {
                resolve(script);
            });
            script.addEventListener("error", function () {
                reject(new Error("".concat(options.src, " failed to load.")));
            });
            script.addEventListener("abort", function () {
                reject(new Error("".concat(options.src, " has aborted.")));
            });
            container.appendChild(script);
        });
        scriptPromiseCache[stringifiedOptions] = scriptLoadPromise;
        return scriptLoadPromise;
    }
    loadScript$1.clearCache = function () {
        scriptPromiseCache = {};
    };
    var loadScript_1$1 = loadScript$1;

    var loadStylesheet$1 = function loadStylesheet(options) {
        var stylesheet = document.querySelector("link[href=\"".concat(options.href, "\"]"));
        if (stylesheet) {
            return Promise.resolve(stylesheet);
        }
        stylesheet = document.createElement("link");
        var container = options.container || document.head;
        stylesheet.setAttribute("rel", "stylesheet");
        stylesheet.setAttribute("type", "text/css");
        stylesheet.setAttribute("href", options.href);
        stylesheet.setAttribute("id", options.id);
        if (container.firstChild) {
            container.insertBefore(stylesheet, container.firstChild);
        }
        else {
            container.appendChild(stylesheet);
        }
        return Promise.resolve(stylesheet);
    };

    Object.defineProperty(dist, "__esModule", { value: true });
    dist.loadStylesheet = loadScript_1 = dist.loadScript = void 0;
    var loadScript = loadScript_1$1;
    var loadScript_1 = dist.loadScript = loadScript;
    var loadStylesheet = loadStylesheet$1;
    dist.loadStylesheet = loadStylesheet;

    var CDNX_PROD = "https://www.paypalobjects.com";
    var ASSET_NAME = {
        minified: "axo.min",
        unminified: "axo",
    };
    var FL_NAMESPACE = "fastlane";
    var ASSET_PATH = "connect-boba";
    var LOCALE_PATH = "".concat(ASSET_PATH, "/locales/");
    var constants = {
        AXO_ASSET_NAME: ASSET_NAME,
        AXO_ASSET_PATH: ASSET_PATH,
        LOCALE_PATH: LOCALE_PATH,
        CDNX_PROD: CDNX_PROD,
    };

    var AxoSupportedPlatforms = {
        BT: "BT",
        PPCP: "PPCP",
    };

    /**
     * Checks if the current environment is an AMD environment.
     *
     * @returns {boolean} True if the environment is AMD, false otherwise.
     */
    function isAmdEnv() {
        return typeof window.define === "function" && !!window.define.amd;
    }
    /**
     * Checks if the current environment is a RequireJS environment.
     *
     * @returns {boolean} True if the environment is RequireJS, false otherwise.
     */
    function isRequireJsEnv() {
        return (isAmdEnv() &&
            typeof window.requirejs === "function" &&
            typeof window.requirejs.config === "function");
    }

    /**
     * Safely loads BT modules by checking if the module already exists and verifying if versions mismatch
     *
     * @param loadConfig <BtModuleLoadConfig> Configuration of BT Module to load
     * @param version <string> version that should be passed from the client getVersion
     * @returns Promise<HTMLScriptElement>
     * @returns Promise<true> when BT module with same version already exists
     * @returns Promise.reject(err) when BT module already exists but versions mismatch or empty version passed in
     */
    function safeLoadBtModule(loadConfig, version, minified) {
        var _a, _b;
        if (minified === void 0) { minified = true; }
        return __awaiter(this, void 0, void 0, function () {
            var bt, existingVersion;
            return __generator(this, function (_c) {
                bt = getBraintree();
                if (bt && bt[loadConfig.module]) {
                    if (version && ((_a = bt[loadConfig.module]) === null || _a === void 0 ? void 0 : _a.VERSION) !== version) {
                        existingVersion = (_b = bt[loadConfig.module]) === null || _b === void 0 ? void 0 : _b.VERSION;
                        throw new Error("".concat(loadConfig.module, " already loaded with version ").concat(existingVersion, " cannot load version ").concat(version));
                    }
                    else {
                        return [2 /*return*/, true];
                    }
                }
                if (!version) {
                    throw new Error("Attempted to load ".concat(loadConfig.module, " without specifying version"));
                }
                return [2 /*return*/, loadBtModule(loadConfig, version, minified)];
            });
        });
    }
    /**
     * Reads the version and to load the correct version of Bt module
     *
     * @param loadConfig <BtModuleLoadConfig> Configuration of BT Module to load
     * @param version <string> Bt module version
     * @returns Promise<HTMLScriptElement> or
     */
    function loadBtModule(loadConfig, version, minified) {
        if (minified === void 0) { minified = true; }
        if (isAmdEnv()) {
            var module_1 = minified
                ? loadConfig.amdModule.minified
                : loadConfig.amdModule.unminified;
            return new Promise(function (resolve, reject) {
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                window.require([module_1], resolve, reject);
            });
        }
        var script = minified
            ? loadConfig.script.minified
            : loadConfig.script.unminified;
        return loadScript_1({
            id: "".concat(loadConfig.id, "-").concat(version),
            src: "https://js.braintreegateway.com/web/".concat(version, "/js/").concat(script),
        });
    }
    /**
     * Looks for the Braintree web sdk on the window object
     *
     * @returns Braintree web sdk
     */
    function getBraintree() {
        return window === null || window === void 0 ? void 0 : window.braintree;
    }

    var _a, _b;
    /**
     * Maps to the BT module namespace created on the window.braintree object
     */
    var BtModule = {
        Client: "client",
        HostedCardFields: "hostedFields",
    };
    var BT_NAMESPACE = "braintree";
    var BT_ASSET_NAME = (_a = {},
        _a[BtModule.Client] = "client",
        _a[BtModule.HostedCardFields] = "hosted-fields",
        _a);
    var btModulesLoadConfig = (_b = {},
        _b[BtModule.Client] = {
            id: "client",
            module: BtModule.Client,
            amdModule: {
                unminified: "".concat(BT_NAMESPACE, "/").concat(BT_ASSET_NAME[BtModule.Client]),
                minified: "".concat(BT_NAMESPACE, "/").concat(BT_ASSET_NAME[BtModule.Client], ".min"),
            },
            script: {
                unminified: "".concat(BT_ASSET_NAME[BtModule.Client], ".js"),
                minified: "".concat(BT_ASSET_NAME[BtModule.Client], ".min.js"),
            },
        },
        _b[BtModule.HostedCardFields] = {
            id: "hcf",
            module: BtModule.HostedCardFields,
            amdModule: {
                unminified: "".concat(BT_NAMESPACE, "/").concat(BT_ASSET_NAME[BtModule.HostedCardFields]),
                minified: "".concat(BT_NAMESPACE, "/").concat(BT_ASSET_NAME[BtModule.HostedCardFields], ".min"),
            },
            script: {
                unminified: "".concat(BT_ASSET_NAME[BtModule.HostedCardFields], ".js"),
                minified: "".concat(BT_ASSET_NAME[BtModule.HostedCardFields], ".min.js"),
            },
        },
        _b);

    /**
     * Loads accelerated checkout components.
     * @param options object with a minified parameter to determine if the script that is loaded should be minified or not (defaults to true if)
     * @returns an object with metadata with a localeUrl parameter to be read by AXO SDK
     */
    function loadAxo(options) {
        return __awaiter(this, void 0, void 0, function () {
            var btSdkVersion, minified, assetUrl, localeUrl;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        performance.mark("pp_axo_sdk_init_invoked");
                        btSdkVersion = options.btSdkVersion, minified = options.minified;
                        assetUrl = getAssetsUrl(options);
                        localeUrl = getLocaleUrl(options);
                        if (!(options.platform === AxoSupportedPlatforms.BT)) return [3 /*break*/, 2];
                        return [4 /*yield*/, Promise.all([
                                safeLoadBtModule(btModulesLoadConfig.hostedFields, btSdkVersion, minified),
                                loadAXOScript(assetUrl, minified),
                            ])];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 5];
                    case 2:
                        if (!(options.platform === AxoSupportedPlatforms.PPCP)) return [3 /*break*/, 4];
                        return [4 /*yield*/, Promise.all([
                                safeLoadBtModule(btModulesLoadConfig.client, btSdkVersion, minified),
                                safeLoadBtModule(btModulesLoadConfig.hostedFields, btSdkVersion, minified),
                                loadAXOScript(assetUrl, minified),
                            ])];
                    case 3:
                        _a.sent();
                        return [3 /*break*/, 5];
                    case 4: throw new Error("unsupported axo platform");
                    case 5: return [2 /*return*/, { metadata: { localeUrl: localeUrl } }];
                }
            });
        });
    }
    /**
     * Reads the url and to load the axo bundle script
     * @param url (Required) string url for the correct axo asset
     * @returns Promise<HTMLScriptElement>
     */
    function loadAXOScript(url, minified) {
        var _a;
        if (minified === void 0) { minified = true; }
        if (isAmdEnv()) {
            // AMD environment
            if (isRequireJsEnv()) {
                // Let's configure RequireJS
                requirejs.config({
                    paths: (_a = {},
                        _a[FL_NAMESPACE] = url,
                        _a),
                });
            }
            var moduleName_1 = "".concat(FL_NAMESPACE, "/").concat(minified
                ? constants.AXO_ASSET_NAME.minified
                : constants.AXO_ASSET_NAME.unminified);
            return new Promise(function (resolve, reject) {
                window.require([moduleName_1], resolve, reject);
            });
        }
        // Not an AMD environment
        return loadScript_1({
            id: "axo-id",
            src: url,
            forceScriptReload: true,
        });
    }
    /**
     * Prepends the domain to the asset url
     * @param options object with assetUrl and bundleid parameters to determine which URL to return
     * @returns full domain and assets URL as string
     */
    function generateAssetUrl(_a) {
        var assetUrl = _a.assetUrl, bundleId = _a.bundleId;
        return bundleId
            ? "https://cdn-".concat(bundleId, ".static.engineering.dev.paypalinc.com/").concat(assetUrl)
            : "".concat(constants.CDNX_PROD, "/").concat(assetUrl);
    }
    /**
     * Retrieves either the minified or unminified assets URL as specified
     * @param options (Optional) object with a minified and metadata with bundleIdOverride parameters to determine which URL to return
     * @returns assets URL as string
     */
    function getAssetsUrl(options) {
        var _a;
        var assetName = (options === null || options === void 0 ? void 0 : options.minified) !== false
            ? constants.AXO_ASSET_NAME.minified
            : constants.AXO_ASSET_NAME.unminified;
        var assetUrl = isAmdEnv()
            ? constants.AXO_ASSET_PATH
            : "".concat(constants.AXO_ASSET_PATH, "/").concat(assetName, ".js");
        return generateAssetUrl({
            assetUrl: assetUrl,
            bundleId: (_a = options === null || options === void 0 ? void 0 : options.metadata) === null || _a === void 0 ? void 0 : _a.bundleIdOverride,
        });
    }
    /**
     * Retrieves the Locales URL, the path to our language files
     * @param options (Optional) object with a minified and metadata with bundleIdOverride parameters to determine which URL to return
     * @returns locale URL as string
     */
    function getLocaleUrl(options) {
        var _a;
        return generateAssetUrl({
            assetUrl: constants.LOCALE_PATH,
            bundleId: (_a = options === null || options === void 0 ? void 0 : options.metadata) === null || _a === void 0 ? void 0 : _a.bundleIdOverride,
        });
    }

    exports.constants = constants;
    exports.loadAxo = loadAxo;

}));

},{}],13:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Framebus = void 0;
var lib_1 = _dereq_("./lib");
var DefaultPromise = (typeof window !== "undefined" &&
    window.Promise);
var Framebus = /** @class */ (function () {
    function Framebus(options) {
        if (options === void 0) { options = {}; }
        this.origin = options.origin || "*";
        this.channel = options.channel || "";
        this.verifyDomain = options.verifyDomain;
        // if a targetFrames configuration is not passed in,
        // the default behavior is to broadcast the payload
        // to the top level window or to the frame itself.
        // By default, the broadcast function will loop through
        // all the known siblings and children of the window.
        // If a targetFrames array is passed, it will instead
        // only broadcast to those specified targetFrames
        this.targetFrames = options.targetFrames || [];
        this.limitBroadcastToFramesArray = Boolean(options.targetFrames);
        this.isDestroyed = false;
        this.listeners = [];
        this.hasAdditionalChecksForOnListeners = Boolean(this.verifyDomain || this.limitBroadcastToFramesArray);
    }
    Framebus.setPromise = function (PromiseGlobal) {
        Framebus.Promise = PromiseGlobal;
    };
    Framebus.target = function (options) {
        return new Framebus(options);
    };
    Framebus.prototype.addTargetFrame = function (frame) {
        if (!this.limitBroadcastToFramesArray) {
            return;
        }
        this.targetFrames.push(frame);
    };
    Framebus.prototype.include = function (childWindow) {
        if (childWindow == null) {
            return false;
        }
        if (childWindow.Window == null) {
            return false;
        }
        if (childWindow.constructor !== childWindow.Window) {
            return false;
        }
        lib_1.childWindows.push(childWindow);
        return true;
    };
    Framebus.prototype.target = function (options) {
        return Framebus.target(options);
    };
    Framebus.prototype.emit = function (eventName, data, reply) {
        if (this.isDestroyed) {
            return false;
        }
        var origin = this.origin;
        eventName = this.namespaceEvent(eventName);
        if ((0, lib_1.isntString)(eventName)) {
            return false;
        }
        if ((0, lib_1.isntString)(origin)) {
            return false;
        }
        if (typeof data === "function") {
            reply = data;
            data = undefined; // eslint-disable-line no-undefined
        }
        var payload = (0, lib_1.packagePayload)(eventName, origin, data, reply);
        if (!payload) {
            return false;
        }
        if (this.limitBroadcastToFramesArray) {
            this.targetFramesAsWindows().forEach(function (frame) {
                (0, lib_1.sendMessage)(frame, payload, origin);
            });
        }
        else {
            (0, lib_1.broadcast)(payload, {
                origin: origin,
                frame: window.top || window.self,
            });
        }
        return true;
    };
    Framebus.prototype.emitAsPromise = function (eventName, data) {
        var _this = this;
        return new Framebus.Promise(function (resolve, reject) {
            var didAttachListener = _this.emit(eventName, data, function (payload) {
                resolve(payload);
            });
            if (!didAttachListener) {
                reject(new Error("Listener not added for \"".concat(eventName, "\"")));
            }
        });
    };
    Framebus.prototype.on = function (eventName, originalHandler) {
        if (this.isDestroyed) {
            return false;
        }
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var self = this;
        var origin = this.origin;
        var handler = originalHandler;
        eventName = this.namespaceEvent(eventName);
        if ((0, lib_1.subscriptionArgsInvalid)(eventName, handler, origin)) {
            return false;
        }
        if (this.hasAdditionalChecksForOnListeners) {
            /* eslint-disable no-invalid-this, @typescript-eslint/ban-ts-comment */
            handler = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                // @ts-ignore
                if (!self.passesVerifyDomainCheck(this && this.origin)) {
                    return;
                }
                // @ts-ignore
                if (!self.hasMatchingTargetFrame(this && this.source)) {
                    return;
                }
                originalHandler.apply(void 0, args);
            };
            /* eslint-enable no-invalid-this, @typescript-eslint/ban-ts-comment */
        }
        this.listeners.push({
            eventName: eventName,
            handler: handler,
            originalHandler: originalHandler,
        });
        lib_1.subscribers[origin] = lib_1.subscribers[origin] || {};
        lib_1.subscribers[origin][eventName] = lib_1.subscribers[origin][eventName] || [];
        lib_1.subscribers[origin][eventName].push(handler);
        return true;
    };
    Framebus.prototype.off = function (eventName, originalHandler) {
        var handler = originalHandler;
        if (this.isDestroyed) {
            return false;
        }
        if (this.hasAdditionalChecksForOnListeners) {
            for (var i = 0; i < this.listeners.length; i++) {
                var listener = this.listeners[i];
                if (listener.originalHandler === originalHandler) {
                    handler = listener.handler;
                }
            }
        }
        eventName = this.namespaceEvent(eventName);
        var origin = this.origin;
        if ((0, lib_1.subscriptionArgsInvalid)(eventName, handler, origin)) {
            return false;
        }
        var subscriberList = lib_1.subscribers[origin] && lib_1.subscribers[origin][eventName];
        if (!subscriberList) {
            return false;
        }
        for (var i = 0; i < subscriberList.length; i++) {
            if (subscriberList[i] === handler) {
                subscriberList.splice(i, 1);
                return true;
            }
        }
        return false;
    };
    Framebus.prototype.teardown = function () {
        if (this.isDestroyed) {
            return;
        }
        this.isDestroyed = true;
        for (var i = 0; i < this.listeners.length; i++) {
            var listener = this.listeners[i];
            this.off(listener.eventName, listener.handler);
        }
        this.listeners.length = 0;
    };
    Framebus.prototype.passesVerifyDomainCheck = function (origin) {
        if (!this.verifyDomain) {
            // always pass this check if no verifyDomain option was set
            return true;
        }
        return this.checkOrigin(origin);
    };
    Framebus.prototype.targetFramesAsWindows = function () {
        if (!this.limitBroadcastToFramesArray) {
            return [];
        }
        return this.targetFrames
            .map(function (frame) {
            // we can't pull off the contentWindow
            // when the iframe is originally added
            // to the array, because if it is not
            // in the DOM at that time, it will have
            // a contentWindow of `null`
            if (frame instanceof HTMLIFrameElement) {
                return frame.contentWindow;
            }
            return frame;
        })
            .filter(function (win) {
            // just in case an iframe element
            // was removed from the DOM
            // and the contentWindow property
            // is null
            return win;
        });
    };
    Framebus.prototype.hasMatchingTargetFrame = function (source) {
        if (!this.limitBroadcastToFramesArray) {
            // always pass this check if we aren't limiting to the target frames
            return true;
        }
        var matchingFrame = this.targetFramesAsWindows().find(function (frame) {
            return frame === source;
        });
        return Boolean(matchingFrame);
    };
    Framebus.prototype.checkOrigin = function (postMessageOrigin) {
        var merchantHost;
        var a = document.createElement("a");
        a.href = location.href;
        if (a.protocol === "https:") {
            merchantHost = a.host.replace(/:443$/, "");
        }
        else if (a.protocol === "http:") {
            merchantHost = a.host.replace(/:80$/, "");
        }
        else {
            merchantHost = a.host;
        }
        var merchantOrigin = a.protocol + "//" + merchantHost;
        if (merchantOrigin === postMessageOrigin) {
            return true;
        }
        if (this.verifyDomain) {
            return this.verifyDomain(postMessageOrigin);
        }
        return true;
    };
    Framebus.prototype.namespaceEvent = function (eventName) {
        if (!this.channel) {
            return eventName;
        }
        return "".concat(this.channel, ":").concat(eventName);
    };
    Framebus.Promise = DefaultPromise;
    return Framebus;
}());
exports.Framebus = Framebus;

},{"./lib":21}],14:[function(_dereq_,module,exports){
"use strict";
var lib_1 = _dereq_("./lib");
var framebus_1 = _dereq_("./framebus");
(0, lib_1.attach)();
module.exports = framebus_1.Framebus;

},{"./framebus":13,"./lib":21}],15:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.detach = exports.attach = void 0;
var _1 = _dereq_("./");
var isAttached = false;
function attach() {
    if (isAttached || typeof window === "undefined") {
        return;
    }
    isAttached = true;
    window.addEventListener("message", _1.onMessage, false);
}
exports.attach = attach;
// removeIf(production)
function detach() {
    isAttached = false;
    window.removeEventListener("message", _1.onMessage, false);
}
exports.detach = detach;
// endRemoveIf(production)

},{"./":21}],16:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.broadcastToChildWindows = void 0;
var _1 = _dereq_("./");
function broadcastToChildWindows(payload, origin, source) {
    for (var i = _1.childWindows.length - 1; i >= 0; i--) {
        var childWindow = _1.childWindows[i];
        if (childWindow.closed) {
            _1.childWindows.splice(i, 1);
        }
        else if (source !== childWindow) {
            (0, _1.broadcast)(payload, {
                origin: origin,
                frame: childWindow.top,
            });
        }
    }
}
exports.broadcastToChildWindows = broadcastToChildWindows;

},{"./":21}],17:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.broadcast = void 0;
var _1 = _dereq_("./");
function broadcast(payload, options) {
    var i = 0;
    var frameToBroadcastTo;
    var origin = options.origin, frame = options.frame;
    try {
        frame.postMessage(payload, origin);
        if ((0, _1.hasOpener)(frame) && frame.opener.top !== window.top) {
            broadcast(payload, {
                origin: origin,
                frame: frame.opener.top,
            });
        }
        // previously, our max value was frame.frames.length
        // but frames.length inherits from window.length
        // which can be overwritten if a developer does
        // `var length = value;` outside of a function
        // scope, it'll prevent us from looping through
        // all the frames. With this, we loop through
        // until there are no longer any frames
        // eslint-disable-next-line no-cond-assign
        while ((frameToBroadcastTo = frame.frames[i])) {
            broadcast(payload, {
                origin: origin,
                frame: frameToBroadcastTo,
            });
            i++;
        }
    }
    catch (_) {
        /* ignored */
    }
}
exports.broadcast = broadcast;

},{"./":21}],18:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.subscribers = exports.childWindows = exports.prefix = void 0;
exports.prefix = "/*framebus*/";
exports.childWindows = [];
exports.subscribers = {};

},{}],19:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dispatch = void 0;
var _1 = _dereq_("./");
function dispatch(origin, event, data, reply, e) {
    if (!_1.subscribers[origin]) {
        return;
    }
    if (!_1.subscribers[origin][event]) {
        return;
    }
    var args = [];
    if (data) {
        args.push(data);
    }
    if (reply) {
        args.push(reply);
    }
    for (var i = 0; i < _1.subscribers[origin][event].length; i++) {
        _1.subscribers[origin][event][i].apply(e, args);
    }
}
exports.dispatch = dispatch;

},{"./":21}],20:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasOpener = void 0;
function hasOpener(frame) {
    if (frame.top !== frame) {
        return false;
    }
    if (frame.opener == null) {
        return false;
    }
    if (frame.opener === frame) {
        return false;
    }
    if (frame.opener.closed === true) {
        return false;
    }
    return true;
}
exports.hasOpener = hasOpener;

},{}],21:[function(_dereq_,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(_dereq_("./attach"), exports);
__exportStar(_dereq_("./broadcast-to-child-windows"), exports);
__exportStar(_dereq_("./broadcast"), exports);
__exportStar(_dereq_("./constants"), exports);
__exportStar(_dereq_("./dispatch"), exports);
__exportStar(_dereq_("./has-opener"), exports);
__exportStar(_dereq_("./is-not-string"), exports);
__exportStar(_dereq_("./message"), exports);
__exportStar(_dereq_("./package-payload"), exports);
__exportStar(_dereq_("./send-message"), exports);
__exportStar(_dereq_("./subscribe-replier"), exports);
__exportStar(_dereq_("./subscription-args-invalid"), exports);
__exportStar(_dereq_("./types"), exports);
__exportStar(_dereq_("./unpack-payload"), exports);

},{"./attach":15,"./broadcast":17,"./broadcast-to-child-windows":16,"./constants":18,"./dispatch":19,"./has-opener":20,"./is-not-string":22,"./message":23,"./package-payload":24,"./send-message":25,"./subscribe-replier":26,"./subscription-args-invalid":27,"./types":28,"./unpack-payload":29}],22:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isntString = void 0;
function isntString(str) {
    return typeof str !== "string";
}
exports.isntString = isntString;

},{}],23:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.onMessage = void 0;
var _1 = _dereq_("./");
function onMessage(e) {
    if ((0, _1.isntString)(e.data)) {
        return;
    }
    var payload = (0, _1.unpackPayload)(e);
    if (!payload) {
        return;
    }
    var data = payload.eventData;
    var reply = payload.reply;
    (0, _1.dispatch)("*", payload.event, data, reply, e);
    (0, _1.dispatch)(e.origin, payload.event, data, reply, e);
    (0, _1.broadcastToChildWindows)(e.data, payload.origin, e.source);
}
exports.onMessage = onMessage;

},{"./":21}],24:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.packagePayload = void 0;
var _1 = _dereq_("./");
function packagePayload(event, origin, data, reply) {
    var packaged;
    var payload = {
        event: event,
        origin: origin,
    };
    if (typeof reply === "function") {
        payload.reply = (0, _1.subscribeReplier)(reply, origin);
    }
    payload.eventData = data;
    try {
        packaged = _1.prefix + JSON.stringify(payload);
    }
    catch (e) {
        throw new Error("Could not stringify event: ".concat(e.message));
    }
    return packaged;
}
exports.packagePayload = packagePayload;

},{"./":21}],25:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendMessage = void 0;
/**
 * A basic function for wrapping the sending of postMessages to frames.
 */
function sendMessage(frame, payload, origin) {
    try {
        frame.postMessage(payload, origin);
    }
    catch (error) {
        /* ignored */
    }
}
exports.sendMessage = sendMessage;

},{}],26:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.subscribeReplier = void 0;
var framebus_1 = _dereq_("../framebus");
var uuid_1 = __importDefault(_dereq_("@braintree/uuid"));
function subscribeReplier(fn, origin) {
    var uuid = (0, uuid_1.default)();
    function replier(data, replyOriginHandler) {
        fn(data, replyOriginHandler);
        framebus_1.Framebus.target({
            origin: origin,
        }).off(uuid, replier);
    }
    framebus_1.Framebus.target({
        origin: origin,
    }).on(uuid, replier);
    return uuid;
}
exports.subscribeReplier = subscribeReplier;

},{"../framebus":13,"@braintree/uuid":7}],27:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.subscriptionArgsInvalid = void 0;
var _1 = _dereq_("./");
function subscriptionArgsInvalid(event, fn, origin) {
    if ((0, _1.isntString)(event)) {
        return true;
    }
    if (typeof fn !== "function") {
        return true;
    }
    return (0, _1.isntString)(origin);
}
exports.subscriptionArgsInvalid = subscriptionArgsInvalid;

},{"./":21}],28:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],29:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unpackPayload = void 0;
var _1 = _dereq_("./");
function unpackPayload(e) {
    var payload;
    if (e.data.slice(0, _1.prefix.length) !== _1.prefix) {
        return false;
    }
    try {
        payload = JSON.parse(e.data.slice(_1.prefix.length));
    }
    catch (err) {
        return false;
    }
    if (payload.reply) {
        var replyOrigin_1 = e.origin;
        var replySource_1 = e.source;
        var replyEvent_1 = payload.reply;
        payload.reply = function reply(replyData) {
            if (!replySource_1) {
                return;
            }
            var replyPayload = (0, _1.packagePayload)(replyEvent_1, replyOrigin_1, replyData);
            if (!replyPayload) {
                return;
            }
            replySource_1.postMessage(replyPayload, replyOrigin_1);
        };
    }
    return payload;
}
exports.unpackPayload = unpackPayload;

},{"./":21}],30:[function(_dereq_,module,exports){
"use strict";

var createAuthorizationData = _dereq_("./create-authorization-data");
var jsonClone = _dereq_("./json-clone");
var constants = _dereq_("./constants");

function addMetadata(configuration, data) {
  var key;
  var attrs = data ? jsonClone(data) : {};
  var authAttrs = createAuthorizationData(configuration.authorization).attrs;
  var _meta = jsonClone(configuration.analyticsMetadata);

  attrs.braintreeLibraryVersion = constants.BRAINTREE_LIBRARY_VERSION;

  for (key in attrs._meta) {
    if (attrs._meta.hasOwnProperty(key)) {
      _meta[key] = attrs._meta[key];
    }
  }

  attrs._meta = _meta;

  if (authAttrs.tokenizationKey) {
    attrs.tokenizationKey = authAttrs.tokenizationKey;
  } else {
    attrs.authorizationFingerprint = authAttrs.authorizationFingerprint;
  }

  return attrs;
}

function addEventMetadata(clientInstanceOrPromise) {
  var configuration = clientInstanceOrPromise.getConfiguration();
  var authAttrs = createAuthorizationData(configuration.authorization).attrs;
  var isProd = configuration.gatewayConfiguration.environment === "production";

  /* eslint-disable camelcase */
  var metadata = {
    api_integration_type: configuration.analyticsMetadata.integrationType,
    app_id: window.location.host,
    c_sdk_ver: constants.VERSION,
    component: "braintreeclientsdk",
    merchant_sdk_env: isProd ? "production" : "sandbox",
    merchant_id: configuration.gatewayConfiguration.merchantId,
    event_source: "web",
    platform: constants.PLATFORM,
    platform_version: window.navigator.userAgent,
    session_id: configuration.analyticsMetadata.sessionId,
    client_session_id: configuration.analyticsMetadata.sessionId,
    tenant_name: "braintree",
  };

  if (authAttrs.tokenizationKey) {
    metadata.tokenization_key = authAttrs.tokenizationKey;
  } else {
    metadata.auth_fingerprint = authAttrs.authorizationFingerprint;
  }
  /* eslint-enable camelcase */

  return metadata;
}

module.exports = {
  addMetadata: addMetadata,
  addEventMetadata: addEventMetadata,
};

},{"./constants":36,"./create-authorization-data":39,"./json-clone":44}],31:[function(_dereq_,module,exports){
"use strict";

var constants = _dereq_("./constants");
var metadata = _dereq_("./add-metadata");
var assign = _dereq_("./assign").assign;

function sendPaypalEvent(clientInstanceOrPromise, eventName, callback) {
  return sendPaypalEventPlusFields(
    clientInstanceOrPromise,
    eventName,
    {},
    callback
  );
}

function sendPaypalEventPlusFields(
  clientInstanceOrPromise,
  eventName,
  extraFields,
  callback
) {
  var timestamp = Date.now();

  return Promise.resolve(clientInstanceOrPromise)
    .then(function (client) {
      var request = client._request;
      var url = constants.ANALYTICS_URL;
      var qualifiedEvent = constants.ANALYTICS_PREFIX + eventName;
      var configuration = client.getConfiguration();
      var isProd =
        configuration.gatewayConfiguration.environment === "production";
      var data = {
        events: [],
        tracking: [],
      };
      var trackingMeta = metadata.addEventMetadata(client, data);

      trackingMeta.event_name = qualifiedEvent; // eslint-disable-line camelcase
      trackingMeta.t = timestamp; // eslint-disable-line camelcase

      data.events = [
        {
          level: "info",
          event: qualifiedEvent,
          payload: {
            env: isProd ? "production" : "sandbox",
            timestamp: timestamp,
          },
        },
      ];
      data.tracking = [trackingMeta];

      if (extraFields && typeof extraFields === "object") {
        data.tracking = [appendExtraFieldsTo(trackingMeta, extraFields)];
      }

      return request(
        {
          url: url,
          method: "post",
          data: data,
          timeout: constants.ANALYTICS_REQUEST_TIMEOUT_MS,
        },
        callback
      );
    })
    .catch(function (err) {
      if (callback) {
        callback(err);
      }
    });
}

function appendExtraFieldsTo(trackingMeta, extraFields) {
  var result = {};
  var allowedExtraFields = assign({}, extraFields);

  Object.keys(allowedExtraFields).forEach(function (field) {
    if (constants.ALLOWED_EXTRA_EVENT_FIELDS.indexOf(field) === -1) {
      delete allowedExtraFields[field];
    }
  });

  result = assign(trackingMeta, allowedExtraFields);

  return result;
}

module.exports = {
  sendEvent: sendPaypalEvent,
  sendEventPlus: sendPaypalEventPlusFields,
};

},{"./add-metadata":30,"./assign":33,"./constants":36}],32:[function(_dereq_,module,exports){
"use strict";

var loadScript = _dereq_("@braintree/asset-loader/load-script");
var loadConnectScript = _dereq_("@paypal/accelerated-checkout-loader");

module.exports = {
  loadScript: loadScript,
  loadFastlane: loadConnectScript.loadAxo,
};

},{"@braintree/asset-loader/load-script":2,"@paypal/accelerated-checkout-loader":12}],33:[function(_dereq_,module,exports){
"use strict";

var assignNormalized =
  typeof Object.assign === "function" ? Object.assign : assignPolyfill;

function assignPolyfill(destination) {
  var i, source, key;

  for (i = 1; i < arguments.length; i++) {
    source = arguments[i];
    for (key in source) {
      if (source.hasOwnProperty(key)) {
        destination[key] = source[key];
      }
    }
  }

  return destination;
}

module.exports = {
  assign: assignNormalized,
  _assign: assignPolyfill,
};

},{}],34:[function(_dereq_,module,exports){
"use strict";

var BraintreeError = _dereq_("./braintree-error");
var sharedErrors = _dereq_("./errors");
var VERSION = "3.115.1";

function basicComponentVerification(options) {
  var client, authorization, name;

  if (!options) {
    return Promise.reject(
      new BraintreeError({
        type: sharedErrors.INVALID_USE_OF_INTERNAL_FUNCTION.type,
        code: sharedErrors.INVALID_USE_OF_INTERNAL_FUNCTION.code,
        message:
          "Options must be passed to basicComponentVerification function.",
      })
    );
  }

  name = options.name;
  client = options.client;
  authorization = options.authorization;

  if (!client && !authorization) {
    return Promise.reject(
      new BraintreeError({
        type: sharedErrors.INSTANTIATION_OPTION_REQUIRED.type,
        code: sharedErrors.INSTANTIATION_OPTION_REQUIRED.code,
        // NEXT_MAJOR_VERSION in major version, we expose passing in authorization for all components
        // instead of passing in a client instance. Leave this a silent feature for now.
        message: "options.client is required when instantiating " + name + ".",
      })
    );
  }

  if (!authorization && client.getVersion() !== VERSION) {
    return Promise.reject(
      new BraintreeError({
        type: sharedErrors.INCOMPATIBLE_VERSIONS.type,
        code: sharedErrors.INCOMPATIBLE_VERSIONS.code,
        message:
          "Client (version " +
          client.getVersion() +
          ") and " +
          name +
          " (version " +
          VERSION +
          ") components must be from the same SDK version.",
      })
    );
  }

  return Promise.resolve();
}

module.exports = {
  verify: basicComponentVerification,
};

},{"./braintree-error":35,"./errors":42}],35:[function(_dereq_,module,exports){
"use strict";

var enumerate = _dereq_("./enumerate");

/**
 * @class
 * @global
 * @param {object} options Construction options
 * @classdesc This class is used to report error conditions, frequently as the first parameter to callbacks throughout the Braintree SDK.
 * @description <strong>You cannot use this constructor directly. Interact with instances of this class through {@link callback callbacks}.</strong>
 */
function BraintreeError(options) {
  if (!BraintreeError.types.hasOwnProperty(options.type)) {
    throw new Error(options.type + " is not a valid type.");
  }

  if (!options.code) {
    throw new Error("Error code required.");
  }

  if (!options.message) {
    throw new Error("Error message required.");
  }

  this.name = "BraintreeError";

  /**
   * @type {string}
   * @description A code that corresponds to specific errors.
   */
  this.code = options.code;

  /**
   * @type {string}
   * @description A short description of the error.
   */
  this.message = options.message;

  /**
   * @type {BraintreeError.types}
   * @description The type of error.
   */
  this.type = options.type;

  /**
   * @type {object=}
   * @description Additional information about the error, such as an underlying network error response.
   */
  this.details = options.details;
}

BraintreeError.prototype = Object.create(Error.prototype);
BraintreeError.prototype.constructor = BraintreeError;

/**
 * Enum for {@link BraintreeError} types.
 * @name BraintreeError.types
 * @enum
 * @readonly
 * @memberof BraintreeError
 * @property {string} CUSTOMER An error caused by the customer.
 * @property {string} MERCHANT An error that is actionable by the merchant.
 * @property {string} NETWORK An error due to a network problem.
 * @property {string} INTERNAL An error caused by Braintree code.
 * @property {string} UNKNOWN An error where the origin is unknown.
 */
BraintreeError.types = enumerate([
  "CUSTOMER",
  "MERCHANT",
  "NETWORK",
  "INTERNAL",
  "UNKNOWN",
]);

BraintreeError.findRootError = function (err) {
  if (
    err instanceof BraintreeError &&
    err.details &&
    err.details.originalError
  ) {
    return BraintreeError.findRootError(err.details.originalError);
  }

  return err;
};

module.exports = BraintreeError;

},{"./enumerate":41}],36:[function(_dereq_,module,exports){
"use strict";

var VERSION = "3.115.1";
var PLATFORM = "web";

var CLIENT_API_URLS = {
  production: "https://api.braintreegateway.com:443",
  sandbox: "https://api.sandbox.braintreegateway.com:443",
};

var ASSETS_URLS = {
  production: "https://assets.braintreegateway.com",
  sandbox: "https://assets.braintreegateway.com",
};

var GRAPHQL_URLS = {
  production: "https://payments.braintree-api.com/graphql",
  sandbox: "https://payments.sandbox.braintree-api.com/graphql",
};

// endRemoveIf(production)

module.exports = {
  ANALYTICS_PREFIX: PLATFORM + ".",
  ANALYTICS_REQUEST_TIMEOUT_MS: 2000,
  ANALYTICS_URL: "https://www.paypal.com/xoplatform/logger/api/logger",
  ASSETS_URLS: ASSETS_URLS,
  CLIENT_API_URLS: CLIENT_API_URLS,
  FRAUDNET_SOURCE: "BRAINTREE_SIGNIN",
  FRAUDNET_FNCLS: "fnparams-dede7cc5-15fd-4c75-a9f4-36c430ee3a99",
  FRAUDNET_URL: "https://c.paypal.com/da/r/fb.js",
  BUS_CONFIGURATION_REQUEST_EVENT: "BUS_CONFIGURATION_REQUEST",
  GRAPHQL_URLS: GRAPHQL_URLS,
  INTEGRATION_TIMEOUT_MS: 60000,
  VERSION: VERSION,
  INTEGRATION: "custom",
  SOURCE: "client",
  PLATFORM: PLATFORM,
  BRAINTREE_LIBRARY_VERSION: "braintree/" + PLATFORM + "/" + VERSION,
  ALLOWED_EXTRA_EVENT_FIELDS: ["paypal_context_id"],
};

},{}],37:[function(_dereq_,module,exports){
"use strict";

var BraintreeError = _dereq_("./braintree-error");
var sharedErrors = _dereq_("./errors");

module.exports = function (instance, methodNames) {
  methodNames.forEach(function (methodName) {
    instance[methodName] = function () {
      throw new BraintreeError({
        type: sharedErrors.METHOD_CALLED_AFTER_TEARDOWN.type,
        code: sharedErrors.METHOD_CALLED_AFTER_TEARDOWN.code,
        message: methodName + " cannot be called after teardown.",
      });
    };
  });
};

},{"./braintree-error":35,"./errors":42}],38:[function(_dereq_,module,exports){
"use strict";

// endRemoveIf(production)
var ASSETS_URLS = _dereq_("./constants").ASSETS_URLS;

function createAssetsUrl(authorization) {
  // endRemoveIf(production)

  return ASSETS_URLS.production;
}
/* eslint-enable */

module.exports = {
  create: createAssetsUrl,
};

},{"./constants":36}],39:[function(_dereq_,module,exports){
"use strict";

var atob = _dereq_("../lib/vendor/polyfill").atob;
var CLIENT_API_URLS = _dereq_("../lib/constants").CLIENT_API_URLS;

function _isTokenizationKey(str) {
  return /^[a-zA-Z0-9]+_[a-zA-Z0-9]+_[a-zA-Z0-9_]+$/.test(str);
}

function _parseTokenizationKey(tokenizationKey) {
  var tokens = tokenizationKey.split("_");
  var environment = tokens[0];
  var merchantId = tokens.slice(2).join("_");

  return {
    merchantId: merchantId,
    environment: environment,
  };
}

function createAuthorizationData(authorization) {
  var parsedClientToken, parsedTokenizationKey;
  var data = {
    attrs: {},
    configUrl: "",
  };

  if (_isTokenizationKey(authorization)) {
    parsedTokenizationKey = _parseTokenizationKey(authorization);
    data.environment = parsedTokenizationKey.environment;
    data.attrs.tokenizationKey = authorization;
    data.configUrl =
      CLIENT_API_URLS[parsedTokenizationKey.environment] +
      "/merchants/" +
      parsedTokenizationKey.merchantId +
      "/client_api/v1/configuration";
  } else {
    parsedClientToken = JSON.parse(atob(authorization));
    data.environment = parsedClientToken.environment;
    data.attrs.authorizationFingerprint =
      parsedClientToken.authorizationFingerprint;
    data.configUrl = parsedClientToken.configUrl;
    data.graphQL = parsedClientToken.graphQL;
  }

  return data;
}

module.exports = createAuthorizationData;

},{"../lib/constants":36,"../lib/vendor/polyfill":47}],40:[function(_dereq_,module,exports){
"use strict";

var BraintreeError = _dereq_("./braintree-error");
var assets = _dereq_("./assets");
var sharedErrors = _dereq_("./errors");

var VERSION = "3.115.1";

function createDeferredClient(options) {
  var promise = Promise.resolve();

  if (options.client) {
    return Promise.resolve(options.client);
  }

  if (!(window.braintree && window.braintree.client)) {
    promise = assets
      .loadScript({
        src: options.assetsUrl + "/web/" + VERSION + "/js/client.min.js",
      })
      .catch(function (err) {
        return Promise.reject(
          new BraintreeError({
            type: sharedErrors.CLIENT_SCRIPT_FAILED_TO_LOAD.type,
            code: sharedErrors.CLIENT_SCRIPT_FAILED_TO_LOAD.code,
            message: sharedErrors.CLIENT_SCRIPT_FAILED_TO_LOAD.message,
            details: {
              originalError: err,
            },
          })
        );
      });
  }

  return promise.then(function () {
    if (window.braintree.client.VERSION !== VERSION) {
      return Promise.reject(
        new BraintreeError({
          type: sharedErrors.INCOMPATIBLE_VERSIONS.type,
          code: sharedErrors.INCOMPATIBLE_VERSIONS.code,
          message:
            "Client (version " +
            window.braintree.client.VERSION +
            ") and " +
            options.name +
            " (version " +
            VERSION +
            ") components must be from the same SDK version.",
        })
      );
    }

    return window.braintree.client.create({
      authorization: options.authorization,
      debug: options.debug,
    });
  });
}

module.exports = {
  create: createDeferredClient,
};

},{"./assets":32,"./braintree-error":35,"./errors":42}],41:[function(_dereq_,module,exports){
"use strict";

function enumerate(values, prefix) {
  prefix = prefix == null ? "" : prefix;

  return values.reduce(function (enumeration, value) {
    enumeration[value] = prefix + value;

    return enumeration;
  }, {});
}

module.exports = enumerate;

},{}],42:[function(_dereq_,module,exports){
"use strict";

/**
 * @name BraintreeError.Shared Internal Error Codes
 * @ignore
 * @description These codes should never be experienced by the merchant directly.
 * @property {INTERNAL} INVALID_USE_OF_INTERNAL_FUNCTION Occurs when the client is created without a gateway configuration. Should never happen.
 */

/**
 * @name BraintreeError.Shared Errors - Component Creation Error Codes
 * @description Errors that occur when creating components.
 * @property {MERCHANT} INSTANTIATION_OPTION_REQUIRED Occurs when a component is created that is missing a required option.
 * @property {MERCHANT} INCOMPATIBLE_VERSIONS Occurs when a component is created with a client with a different version than the component.
 * @property {NETWORK} CLIENT_SCRIPT_FAILED_TO_LOAD Occurs when a component attempts to load the Braintree client script, but the request fails.
 */

/**
 * @name BraintreeError.Shared Errors - Component Instance Error Codes
 * @description Errors that occur when using instances of components.
 * @property {MERCHANT} METHOD_CALLED_AFTER_TEARDOWN Occurs when a method is called on a component instance after it has been torn down.
 */

var BraintreeError = _dereq_("./braintree-error");

module.exports = {
  INVALID_USE_OF_INTERNAL_FUNCTION: {
    type: BraintreeError.types.INTERNAL,
    code: "INVALID_USE_OF_INTERNAL_FUNCTION",
  },
  INSTANTIATION_OPTION_REQUIRED: {
    type: BraintreeError.types.MERCHANT,
    code: "INSTANTIATION_OPTION_REQUIRED",
  },
  INCOMPATIBLE_VERSIONS: {
    type: BraintreeError.types.MERCHANT,
    code: "INCOMPATIBLE_VERSIONS",
  },
  CLIENT_SCRIPT_FAILED_TO_LOAD: {
    type: BraintreeError.types.NETWORK,
    code: "CLIENT_SCRIPT_FAILED_TO_LOAD",
    message: "Braintree client script could not be loaded.",
  },
  METHOD_CALLED_AFTER_TEARDOWN: {
    type: BraintreeError.types.MERCHANT,
    code: "METHOD_CALLED_AFTER_TEARDOWN",
  },
};

},{"./braintree-error":35}],43:[function(_dereq_,module,exports){
"use strict";

var parser;
var legalHosts = {
  "paypal.com": 1,
  "braintreepayments.com": 1,
  "braintreegateway.com": 1,
  "braintree-api.com": 1,
};

// endRemoveIf(production)

function stripSubdomains(domain) {
  return domain.split(".").slice(-2).join(".");
}

function isVerifiedDomain(url) {
  var mainDomain;

  url = url.toLowerCase();

  if (!/^https:/.test(url)) {
    return false;
  }

  parser = parser || document.createElement("a");
  parser.href = url;
  mainDomain = stripSubdomains(parser.hostname);

  return legalHosts.hasOwnProperty(mainDomain);
}

module.exports = isVerifiedDomain;

},{}],44:[function(_dereq_,module,exports){
"use strict";

module.exports = function (value) {
  return JSON.parse(JSON.stringify(value));
};

},{}],45:[function(_dereq_,module,exports){
"use strict";

module.exports = function (obj) {
  return Object.keys(obj).filter(function (key) {
    return typeof obj[key] === "function";
  });
};

},{}],46:[function(_dereq_,module,exports){
"use strict";

function useMin(isDebug) {
  return isDebug ? "" : ".min";
}

module.exports = useMin;

},{}],47:[function(_dereq_,module,exports){
"use strict";

// NEXT_MAJOR_VERSION old versions of IE don't have atob, in the
// next major version, we're dropping support for those versions
// so we can eliminate the need to have this atob polyfill
var atobNormalized = typeof atob === "function" ? atob : atobPolyfill;

function atobPolyfill(base64String) {
  var a, b, c, b1, b2, b3, b4, i;
  var base64Matcher = new RegExp(
    "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})([=]{1,2})?$"
  );
  var characters =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  var result = "";

  if (!base64Matcher.test(base64String)) {
    throw new Error("Non base64 encoded input passed to window.atob polyfill");
  }

  i = 0;
  do {
    b1 = characters.indexOf(base64String.charAt(i++));
    b2 = characters.indexOf(base64String.charAt(i++));
    b3 = characters.indexOf(base64String.charAt(i++));
    b4 = characters.indexOf(base64String.charAt(i++));

    a = ((b1 & 0x3f) << 2) | ((b2 >> 4) & 0x3);
    b = ((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf);
    c = ((b3 & 0x3) << 6) | (b4 & 0x3f);

    result +=
      String.fromCharCode(a) +
      (b ? String.fromCharCode(b) : "") +
      (c ? String.fromCharCode(c) : "");
  } while (i < base64String.length);

  return result;
}

module.exports = {
  atob: function (base64String) {
    return atobNormalized.call(window, base64String);
  },
  _atob: atobPolyfill,
};

},{}],48:[function(_dereq_,module,exports){
"use strict";
/**
 * @module braintree-web/unionpay
 * @description This module allows you to accept UnionPay payments. *It is currently in beta and is subject to change.*
 */

var UnionPay = _dereq_("./shared/unionpay");
var basicComponentVerification = _dereq_("../lib/basic-component-verification");
var BraintreeError = _dereq_("../lib/braintree-error");
var createDeferredClient = _dereq_("../lib/create-deferred-client");
var createAssetsUrl = _dereq_("../lib/create-assets-url");
var analytics = _dereq_("../lib/analytics");
var errors = _dereq_("./shared/errors");
var VERSION = "3.115.1";
var wrapPromise = _dereq_("@braintree/wrap-promise");

/**
 * @static
 * @function create
 * @param {object} options Creation options:
 * @param {Client} [options.client] A {@link Client} instance.
 * @param {string} [options.authorization] A tokenizationKey or clientToken. Can be used in place of `options.client`.
 * @param {callback} [callback] The second argument, `data`, is the {@link UnionPay} instance. If no callback is provided, `create` returns a promise that resolves with the {@link UnionPay} instance.
 * @returns {(Promise|void)} Returns a promise if no callback is provided.
 * @example
 * braintree.unionpay.create({ client: clientInstance }, function (createErr, unionpayInstance) {
 *   if (createErr) {
 *     console.error(createErr);
 *     return;
 *   }
 *   // ...
 * });
 */
function create(options) {
  var name = "UnionPay";

  return basicComponentVerification
    .verify({
      name: name,
      client: options.client,
      authorization: options.authorization,
    })
    .then(function () {
      return createDeferredClient.create({
        authorization: options.authorization,
        client: options.client,
        debug: options.debug,
        assetsUrl: createAssetsUrl.create(options.authorization),
        name: name,
      });
    })
    .then(function (client) {
      var config = client.getConfiguration();

      options.client = client;

      if (
        !config.gatewayConfiguration.unionPay ||
        config.gatewayConfiguration.unionPay.enabled !== true
      ) {
        return Promise.reject(new BraintreeError(errors.UNIONPAY_NOT_ENABLED));
      }

      analytics.sendEvent(options.client, "unionpay.initialized");

      return new UnionPay(options);
    });
}

module.exports = {
  create: wrapPromise(create),
  /**
   * @description The current version of the SDK, i.e. `{@pkg version}`.
   * @type {string}
   */
  VERSION: VERSION,
};

},{"../lib/analytics":31,"../lib/basic-component-verification":34,"../lib/braintree-error":35,"../lib/create-assets-url":38,"../lib/create-deferred-client":40,"./shared/errors":50,"./shared/unionpay":51,"@braintree/wrap-promise":11}],49:[function(_dereq_,module,exports){
"use strict";

var enumerate = _dereq_("../../lib/enumerate");

module.exports = {
  events: enumerate(
    [
      "HOSTED_FIELDS_FETCH_CAPABILITIES",
      "HOSTED_FIELDS_ENROLL",
      "HOSTED_FIELDS_TOKENIZE",
    ],
    "union-pay:"
  ),
  HOSTED_FIELDS_FRAME_NAME: "braintreeunionpayhostedfields",
};

},{"../../lib/enumerate":41}],50:[function(_dereq_,module,exports){
"use strict";

/**
 * @name BraintreeError.Union Pay - Creation Error Codes
 * @description Errors that occur when [creating the Union Pay component](./module-braintree-web_union-pay.html#.create).
 * @property {MERCHANT} UNIONPAY_NOT_ENABLED Occurs when Union Pay is not enabled on the Braintree control panel.
 */

/**
 * @name BraintreeError.Union Pay - Shared Error Codes
 * @description Errors that occur when starting the Union Pay Flow
 * @property {MERCHANT} UNIONPAY_CARD_AND_HOSTED_FIELDS_INSTANCES Occurs when a method is used with both card details and a Hosted Fields instance.
 * @property {MERCHANT} UNIONPAY_HOSTED_FIELDS_INSTANCE_INVALID Occurs when Hosted Fields instance used is not a valid Hosted Fields instance.
 * @property {MERCHANT} UNIONPAY_CARD_OR_HOSTED_FIELDS_INSTANCE_REQUIRED Occurs when neither card details or Hosted Fields are used.
 * @property {MERCHANT} UNIONPAY_HOSTED_FIELDS_INSTANCE_REQUIRED Occurs when Hosted Fields cannot be found on the page.
 */

/**
 * @name BraintreeError.Union Pay - fetchCapabilities Error Codes
 * @description Errors that occur when using the [`fetchCapabilities` method](./UnionPay.html#fetchCapabilities).
 * @property {NETWORK} UNIONPAY_FETCH_CAPABILITIES_NETWORK_ERROR Occurs when there is an error looking up the Union Pay capabilities.
 */

/**
 * @name BraintreeError.Union Pay - enroll Error Codes
 * @description Errors that occur when using the [`enroll` method](./UnionPay.html#enroll).
 * @property {MERCHANT} UNIONPAY_MISSING_MOBILE_PHONE_DATA Occurs when no mobile phone data is provided.
 * @property {MERCHANT} UNIONPAY_EXPIRATION_DATE_INCOMPLETE Occurs when expiration date is incomplete.
 * @property {CUSTOMER} UNIONPAY_ENROLLMENT_CUSTOMER_INPUT_INVALID Occurs when customer enrollment input is invalid.
 * @property {NETWORK} UNIONPAY_ENROLLMENT_NETWORK_ERROR Occurs when there is an error during enrollment.
 */

/**
 * @name BraintreeError.Union Pay - tokenize Error Codes
 * @description Errors that occur when using the [`tokenize` method](./UnionPay.html#tokenize).
 * @property {CUSTOMER} UNIONPAY_FAILED_TOKENIZATION Occurs when data cannot be tokenized.
 * @property {NETWORK} UNIONPAY_TOKENIZATION_NETWORK_ERROR Occurs when the Braintree gateway cannot be reached.
 */

var BraintreeError = _dereq_("../../lib/braintree-error");

module.exports = {
  UNIONPAY_NOT_ENABLED: {
    type: BraintreeError.types.MERCHANT,
    code: "UNIONPAY_NOT_ENABLED",
    message: "UnionPay is not enabled for this merchant.",
  },
  UNIONPAY_HOSTED_FIELDS_INSTANCE_INVALID: {
    type: BraintreeError.types.MERCHANT,
    code: "UNIONPAY_HOSTED_FIELDS_INSTANCE_INVALID",
    message:
      "Found an invalid Hosted Fields instance. Please use a valid Hosted Fields instance.",
  },
  UNIONPAY_HOSTED_FIELDS_INSTANCE_REQUIRED: {
    type: BraintreeError.types.MERCHANT,
    code: "UNIONPAY_HOSTED_FIELDS_INSTANCE_REQUIRED",
    message: "Could not find the Hosted Fields instance.",
  },
  UNIONPAY_CARD_OR_HOSTED_FIELDS_INSTANCE_REQUIRED: {
    type: BraintreeError.types.MERCHANT,
    code: "UNIONPAY_CARD_OR_HOSTED_FIELDS_INSTANCE_REQUIRED",
    message:
      "A card or a Hosted Fields instance is required. Please supply a card or a Hosted Fields instance.",
  },
  UNIONPAY_CARD_AND_HOSTED_FIELDS_INSTANCES: {
    type: BraintreeError.types.MERCHANT,
    code: "UNIONPAY_CARD_AND_HOSTED_FIELDS_INSTANCES",
    message:
      "Please supply either a card or a Hosted Fields instance, not both.",
  },
  UNIONPAY_EXPIRATION_DATE_INCOMPLETE: {
    type: BraintreeError.types.MERCHANT,
    code: "UNIONPAY_EXPIRATION_DATE_INCOMPLETE",
    message: "You must supply expiration month and year or neither.",
  },
  UNIONPAY_ENROLLMENT_CUSTOMER_INPUT_INVALID: {
    type: BraintreeError.types.CUSTOMER,
    code: "UNIONPAY_ENROLLMENT_CUSTOMER_INPUT_INVALID",
    message: "Enrollment failed due to user input error.",
  },
  UNIONPAY_ENROLLMENT_NETWORK_ERROR: {
    type: BraintreeError.types.NETWORK,
    code: "UNIONPAY_ENROLLMENT_NETWORK_ERROR",
    message: "Could not enroll UnionPay card.",
  },
  UNIONPAY_FETCH_CAPABILITIES_NETWORK_ERROR: {
    type: BraintreeError.types.NETWORK,
    code: "UNIONPAY_FETCH_CAPABILITIES_NETWORK_ERROR",
    message: "Could not fetch card capabilities.",
  },
  UNIONPAY_TOKENIZATION_NETWORK_ERROR: {
    type: BraintreeError.types.NETWORK,
    code: "UNIONPAY_TOKENIZATION_NETWORK_ERROR",
    message: "A tokenization network error occurred.",
  },
  UNIONPAY_MISSING_MOBILE_PHONE_DATA: {
    type: BraintreeError.types.MERCHANT,
    code: "UNIONPAY_MISSING_MOBILE_PHONE_DATA",
    message: "A `mobile` with `countryCode` and `number` is required.",
  },
  UNIONPAY_FAILED_TOKENIZATION: {
    type: BraintreeError.types.CUSTOMER,
    code: "UNIONPAY_FAILED_TOKENIZATION",
    message: "The supplied card data failed tokenization.",
  },
};

},{"../../lib/braintree-error":35}],51:[function(_dereq_,module,exports){
"use strict";

var analytics = _dereq_("../../lib/analytics");
var BraintreeError = _dereq_("../../lib/braintree-error");
var Bus = _dereq_("framebus");
var constants = _dereq_("./constants");
var isVerifiedDomain = _dereq_("../../lib/is-verified-domain");
var useMin = _dereq_("../../lib/use-min");
var convertMethodsToError = _dereq_("../../lib/convert-methods-to-error");
var errors = _dereq_("./errors");
var events = constants.events;
var iFramer = _dereq_("@braintree/iframer");
var methods = _dereq_("../../lib/methods");
var VERSION = "3.115.1";
var uuid = _dereq_("@braintree/uuid");
var wrapPromise = _dereq_("@braintree/wrap-promise");
var BUS_CONFIGURATION_REQUEST_EVENT =
  _dereq_("../../lib/constants").BUS_CONFIGURATION_REQUEST_EVENT;

/**
 * @class
 * @param {object} options See {@link module:braintree-web/unionpay.create|unionpay.create}.
 * @description <strong>You cannot use this constructor directly. Use {@link module:braintree-web/unionpay.create|braintree-web.unionpay.create} instead.</strong>
 * @classdesc This class represents a UnionPay component. Instances of this class have methods for {@link UnionPay#fetchCapabilities fetching capabilities} of UnionPay cards, {@link UnionPay#enroll enrolling} a UnionPay card, and {@link UnionPay#tokenize tokenizing} a UnionPay card.
 */
function UnionPay(options) {
  this._options = options;
}

/**
 * @typedef {object} UnionPay~fetchCapabilitiesPayload
 * @property {boolean} isUnionPay Determines if this card is a UnionPay card.
 * @property {boolean} isDebit Determines if this card is a debit card. This property is only present if `isUnionPay` is `true`.
 * @property {object} unionPay UnionPay specific properties. This property is only present if `isUnionPay` is `true`.
 * @property {boolean} unionPay.supportsTwoStepAuthAndCapture Determines if the card allows for an authorization, but settling the transaction later.
 * @property {boolean} unionPay.isSupported Determines if Braintree can process this UnionPay card. When false, Braintree cannot process this card and the user should use a different card.
 */

/**
 * Fetches the capabilities of a card, including whether or not the SMS enrollment process is required.
 * @public
 * @param {object} options UnionPay {@link UnionPay#fetchCapabilities fetchCapabilities} options
 * @param {object} [options.card] The card from which to fetch capabilities. Note that this will only have one property, `number`. Required if you are not using the `hostedFields` option.
 * @param {string} options.card.number Card number.
 * @param {HostedFields} [options.hostedFields] The Hosted Fields instance used to collect card data. Required if you are not using the `card` option.
 * @param {callback} [callback] The second argument, <code>data</code>, is a {@link UnionPay#fetchCapabilitiesPayload fetchCapabilitiesPayload}. If no callback is provided, `fetchCapabilities` returns a promise that resolves with a {@link UnionPay#fetchCapabilitiesPayload fetchCapabilitiesPayload}.
 * @returns {(Promise|void)} Returns a promise if no callback is provided.
 */
UnionPay.prototype.fetchCapabilities = function (options) {
  var self = this;
  var client = this._options.client;
  var cardNumber = options.card ? options.card.number : null;
  var hostedFields = options.hostedFields;

  if (cardNumber && hostedFields) {
    return Promise.reject(
      new BraintreeError(errors.UNIONPAY_CARD_AND_HOSTED_FIELDS_INSTANCES)
    );
  } else if (cardNumber) {
    return client
      .request({
        method: "get",
        endpoint: "payment_methods/credit_cards/capabilities",
        data: {
          _meta: { source: "unionpay" },
          creditCard: {
            number: cardNumber,
          },
        },
      })
      .then(function (response) {
        analytics.sendEvent(client, "unionpay.capabilities-received");

        return response;
      })
      .catch(function (err) {
        var status = err.details && err.details.httpStatus;

        analytics.sendEvent(client, "unionpay.capabilities-failed");

        if (status === 403) {
          return Promise.reject(err);
        }

        return Promise.reject(
          new BraintreeError({
            type: errors.UNIONPAY_FETCH_CAPABILITIES_NETWORK_ERROR.type,
            code: errors.UNIONPAY_FETCH_CAPABILITIES_NETWORK_ERROR.code,
            message: errors.UNIONPAY_FETCH_CAPABILITIES_NETWORK_ERROR.message,
            details: {
              originalError: err,
            },
          })
        );
      });
  } else if (hostedFields) {
    if (!hostedFields._bus) {
      return Promise.reject(
        new BraintreeError(errors.UNIONPAY_HOSTED_FIELDS_INSTANCE_INVALID)
      );
    }

    return self._initializeHostedFields().then(function () {
      return new Promise(function (resolve, reject) {
        self._bus.emit(
          events.HOSTED_FIELDS_FETCH_CAPABILITIES,
          { hostedFields: hostedFields },
          function (response) {
            if (response.err) {
              reject(new BraintreeError(response.err));

              return;
            }

            resolve(response.payload);
          }
        );
      });
    });
  }

  return Promise.reject(
    new BraintreeError(errors.UNIONPAY_CARD_OR_HOSTED_FIELDS_INSTANCE_REQUIRED)
  );
};

/**
 * @typedef {object} UnionPay~enrollPayload
 * @property {string} enrollmentId UnionPay enrollment ID. This value should be passed to `tokenize`.
 * @property {boolean} smsCodeRequired UnionPay `smsCodeRequired` flag.
 * </p><b>true</b> - the user will receive an SMS code that needs to be supplied for tokenization.
 * </p><b>false</b> - the card can be immediately tokenized.
 */

/**
 * Enrolls a UnionPay card. Use {@link UnionPay#fetchCapabilities|fetchCapabilities} to determine if the SMS enrollment process is required.
 * @public
 * @param {object} options UnionPay enrollment options:
 * @param {object} [options.card] The card to enroll. Required if you are not using the `hostedFields` option.
 * @param {string} options.card.number The card number.
 * @param {string} [options.card.expirationDate] The card's expiration date. May be in the form `MM/YY` or `MM/YYYY`. When defined `expirationMonth` and `expirationYear` are ignored.
 * @param {string} [options.card.expirationMonth] The card's expiration month. This should be used with the `expirationYear` parameter. When `expirationDate` is defined this parameter is ignored.
 * @param {string} [options.card.expirationYear] The card's expiration year. This should be used with the `expirationMonth` parameter. When `expirationDate` is defined this parameter is ignored.
 * @param {HostedFields} [options.hostedFields] The Hosted Fields instance used to collect card data. Required if you are not using the `card` option.
 * @param {object} options.mobile The mobile information collected from the customer.
 * @param {string} options.mobile.countryCode The country code of the customer's mobile phone number.
 * @param {string} options.mobile.number The customer's mobile phone number.
 * @param {callback} [callback] The second argument, <code>data</code>, is a {@link UnionPay~enrollPayload|enrollPayload}. If no callback is provided, `enroll` returns a promise that resolves with {@link UnionPay~enrollPayload|enrollPayload}.
 * @returns {void}
 */
UnionPay.prototype.enroll = function (options) {
  var self = this;
  var client = this._options.client;
  var card = options.card;
  var mobile = options.mobile;
  var hostedFields = options.hostedFields;
  var data;

  if (!mobile) {
    return Promise.reject(
      new BraintreeError(errors.UNIONPAY_MISSING_MOBILE_PHONE_DATA)
    );
  }

  if (hostedFields) {
    if (!hostedFields._bus) {
      return Promise.reject(
        new BraintreeError(errors.UNIONPAY_HOSTED_FIELDS_INSTANCE_INVALID)
      );
    } else if (card) {
      return Promise.reject(
        new BraintreeError(errors.UNIONPAY_CARD_AND_HOSTED_FIELDS_INSTANCES)
      );
    }

    return new Promise(function (resolve, reject) {
      self._initializeHostedFields().then(function () {
        self._bus.emit(
          events.HOSTED_FIELDS_ENROLL,
          { hostedFields: hostedFields, mobile: mobile },
          function (response) {
            if (response.err) {
              reject(new BraintreeError(response.err));

              return;
            }

            resolve(response.payload);
          }
        );
      });
    });
  } else if (card && card.number) {
    data = {
      _meta: { source: "unionpay" },
      unionPayEnrollment: {
        number: card.number,
        mobileCountryCode: mobile.countryCode,
        mobileNumber: mobile.number,
      },
    };

    if (card.expirationDate) {
      data.unionPayEnrollment.expirationDate = card.expirationDate;
    } else if (card.expirationMonth || card.expirationYear) {
      if (card.expirationMonth && card.expirationYear) {
        data.unionPayEnrollment.expirationYear = card.expirationYear;
        data.unionPayEnrollment.expirationMonth = card.expirationMonth;
      } else {
        return Promise.reject(
          new BraintreeError(errors.UNIONPAY_EXPIRATION_DATE_INCOMPLETE)
        );
      }
    }

    return client
      .request({
        method: "post",
        endpoint: "union_pay_enrollments",
        data: data,
      })
      .then(function (response) {
        analytics.sendEvent(client, "unionpay.enrollment-succeeded");

        return {
          enrollmentId: response.unionPayEnrollmentId,
          smsCodeRequired: response.smsCodeRequired,
        };
      })
      .catch(function (err) {
        var error;
        var status = err.details && err.details.httpStatus;

        if (status === 403) {
          error = err;
        } else if (status < 500) {
          error = new BraintreeError(
            errors.UNIONPAY_ENROLLMENT_CUSTOMER_INPUT_INVALID
          );
          error.details = { originalError: err };
        } else {
          error = new BraintreeError(errors.UNIONPAY_ENROLLMENT_NETWORK_ERROR);
          error.details = { originalError: err };
        }

        analytics.sendEvent(client, "unionpay.enrollment-failed");

        return Promise.reject(error);
      });
  }

  return Promise.reject(
    new BraintreeError(errors.UNIONPAY_CARD_OR_HOSTED_FIELDS_INSTANCE_REQUIRED)
  );
};

/**
 * @typedef {object} UnionPay~tokenizePayload
 * @property {string} nonce The payment method nonce.
 * @property {string} type Always <code>CreditCard</code>.
 * @property {object} details Additional account details:
 * @property {string} details.cardType Type of card, ex: Visa, MasterCard.
 * @property {string} details.lastFour Last four digits of card number.
 * @property {string} details.lastTwo Last two digits of card number.
 * @property {string} description A human-readable description.
 */

/**
 * Tokenizes a UnionPay card and returns a nonce payload.
 * @public
 * @param {object} options UnionPay tokenization options:
 * @param {object} [options.card] The card to enroll. Required if you are not using the `hostedFields` option.
 * @param {string} options.card.number The card number.
 * @param {string} [options.card.expirationDate] The card's expiration date. May be in the form `MM/YY` or `MM/YYYY`. When defined `expirationMonth` and `expirationYear` are ignored.
 * @param {string} [options.card.expirationMonth] The card's expiration month. This should be used with the `expirationYear` parameter. When `expirationDate` is defined this parameter is ignored.
 * @param {string} [options.card.expirationYear] The card's expiration year. This should be used with the `expirationMonth` parameter. When `expirationDate` is defined this parameter is ignored.
 * @param {string} [options.card.cvv] The card's security number.
 * @param {HostedFields} [options.hostedFields] The Hosted Fields instance used to collect card data. Required if you are not using the `card` option.
 * @param {string} options.enrollmentId The enrollment ID from {@link UnionPay#enroll}.
 * @param {string} [options.smsCode] The SMS code received from the user if {@link UnionPay#enroll} payload have `smsCodeRequired`. if `smsCodeRequired` is false, smsCode should not be passed.
 * @param {callback} [callback] The second argument, <code>data</code>, is a {@link UnionPay~tokenizePayload|tokenizePayload}. If no callback is provided, `tokenize` returns a promise that resolves with a {@link UnionPay~tokenizePayload|tokenizePayload}.
 * @returns {(Promise|void)} Returns a promise if no callback is provided.
 */
UnionPay.prototype.tokenize = function (options) {
  var data;
  var self = this;
  var client = this._options.client;
  var card = options.card;
  var hostedFields = options.hostedFields;

  if (card && hostedFields) {
    return Promise.reject(
      new BraintreeError(errors.UNIONPAY_CARD_AND_HOSTED_FIELDS_INSTANCES)
    );
  } else if (card) {
    data = {
      _meta: { source: "unionpay" },
      creditCard: {
        number: options.card.number,
        options: {
          unionPayEnrollment: {
            id: options.enrollmentId,
          },
        },
      },
    };

    if (options.smsCode) {
      data.creditCard.options.unionPayEnrollment.smsCode = options.smsCode;
    }

    if (card.expirationDate) {
      data.creditCard.expirationDate = card.expirationDate;
    } else if (card.expirationMonth && card.expirationYear) {
      data.creditCard.expirationYear = card.expirationYear;
      data.creditCard.expirationMonth = card.expirationMonth;
    }

    if (options.card.cvv) {
      data.creditCard.cvv = options.card.cvv;
    }

    return client
      .request({
        method: "post",
        endpoint: "payment_methods/credit_cards",
        data: data,
      })
      .then(function (response) {
        var tokenizedCard = response.creditCards[0];

        delete tokenizedCard.consumed;
        delete tokenizedCard.threeDSecureInfo;

        analytics.sendEvent(client, "unionpay.nonce-received");

        return tokenizedCard;
      })
      .catch(function (err) {
        var error;
        var status = err.details && err.details.httpStatus;

        analytics.sendEvent(client, "unionpay.nonce-failed");

        if (status === 403) {
          error = err;
        } else if (status < 500) {
          error = new BraintreeError(errors.UNIONPAY_FAILED_TOKENIZATION);
          error.details = { originalError: err };
        } else {
          error = new BraintreeError(
            errors.UNIONPAY_TOKENIZATION_NETWORK_ERROR
          );
          error.details = { originalError: err };
        }

        return Promise.reject(error);
      });
  } else if (hostedFields) {
    if (!hostedFields._bus) {
      return Promise.reject(
        new BraintreeError(errors.UNIONPAY_HOSTED_FIELDS_INSTANCE_INVALID)
      );
    }

    return new Promise(function (resolve, reject) {
      self._initializeHostedFields().then(function () {
        self._bus.emit(
          events.HOSTED_FIELDS_TOKENIZE,
          options,
          function (response) {
            if (response.err) {
              reject(new BraintreeError(response.err));

              return;
            }

            resolve(response.payload);
          }
        );
      });
    });
  }

  return Promise.reject(
    new BraintreeError(errors.UNIONPAY_CARD_OR_HOSTED_FIELDS_INSTANCE_REQUIRED)
  );
};

/**
 * Cleanly remove anything set up by {@link module:braintree-web/unionpay.create|create}. This only needs to be called when using UnionPay with Hosted Fields.
 * @public
 * @param {callback} [callback] Called on completion. If no callback is provided, returns a promise.
 * @example
 * unionpayInstance.teardown();
 * @returns {(Promise|void)} Returns a promise if no callback is provided.
 */
UnionPay.prototype.teardown = function () {
  if (this._bus) {
    this._hostedFieldsFrame.parentNode.removeChild(this._hostedFieldsFrame);
    this._bus.teardown();
  }

  convertMethodsToError(this, methods(UnionPay.prototype));

  return Promise.resolve();
};

UnionPay.prototype._initializeHostedFields = function () {
  var assetsUrl, isDebug;
  var componentId = uuid();
  var self = this;

  if (this._hostedFieldsInitializePromise) {
    return this._hostedFieldsInitializePromise;
  }

  this._hostedFieldsInitializePromise = new Promise(function (resolve) {
    assetsUrl =
      self._options.client.getConfiguration().gatewayConfiguration.assetsUrl;
    isDebug = self._options.client.getConfiguration().isDebug;

    self._bus = new Bus({
      channel: componentId,
      verifyDomain: isVerifiedDomain,
    });
    self._hostedFieldsFrame = iFramer({
      name: constants.HOSTED_FIELDS_FRAME_NAME + "_" + componentId,
      src:
        assetsUrl +
        "/web/" +
        VERSION +
        "/html/unionpay-hosted-fields-frame" +
        useMin(isDebug) +
        ".html",
      height: 0,
      width: 0,
    });

    self._bus.on(BUS_CONFIGURATION_REQUEST_EVENT, function (reply) {
      reply(self._options.client);

      resolve();
    });

    document.body.appendChild(self._hostedFieldsFrame);
  });

  return this._hostedFieldsInitializePromise;
};

module.exports = wrapPromise.wrapPrototype(UnionPay);

},{"../../lib/analytics":31,"../../lib/braintree-error":35,"../../lib/constants":36,"../../lib/convert-methods-to-error":37,"../../lib/is-verified-domain":43,"../../lib/methods":45,"../../lib/use-min":46,"./constants":49,"./errors":50,"@braintree/iframer":3,"@braintree/uuid":7,"@braintree/wrap-promise":11,"framebus":14}]},{},[48])(48)
});
