(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.braintree || (g.braintree = {})).americanExpress = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(_dereq_,module,exports){
"use strict";
var scriptPromiseCache = {};
function loadScript(options) {
    var scriptLoadPromise;
    var stringifiedOptions = JSON.stringify(options);
    if (!options.forceScriptReload) {
        scriptLoadPromise = scriptPromiseCache[stringifiedOptions];
        if (scriptLoadPromise) {
            return scriptLoadPromise;
        }
    }
    var script = document.createElement("script");
    var attrs = options.dataAttributes || {};
    var container = options.container || document.head;
    script.src = options.src;
    script.id = options.id || "";
    script.async = true;
    if (options.type) {
        script.setAttribute("type", "".concat(options.type));
    }
    if (options.crossorigin) {
        script.setAttribute("crossorigin", "".concat(options.crossorigin));
    }
    Object.keys(attrs).forEach(function (key) {
        script.setAttribute("data-".concat(key), "".concat(attrs[key]));
    });
    scriptLoadPromise = new Promise(function (resolve, reject) {
        script.addEventListener("load", function () {
            resolve(script);
        });
        script.addEventListener("error", function () {
            reject(new Error("".concat(options.src, " failed to load.")));
        });
        script.addEventListener("abort", function () {
            reject(new Error("".concat(options.src, " has aborted.")));
        });
        container.appendChild(script);
    });
    scriptPromiseCache[stringifiedOptions] = scriptLoadPromise;
    return scriptLoadPromise;
}
loadScript.clearCache = function () {
    scriptPromiseCache = {};
};
module.exports = loadScript;

},{}],2:[function(_dereq_,module,exports){
module.exports = _dereq_("./dist/load-script");

},{"./dist/load-script":1}],3:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function deferred(fn) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        setTimeout(function () {
            try {
                fn.apply(void 0, args);
            }
            catch (err) {
                /* eslint-disable no-console */
                console.log("Error in callback function");
                console.log(err);
                /* eslint-enable no-console */
            }
        }, 1);
    };
}
exports.deferred = deferred;

},{}],4:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function once(fn) {
    var called = false;
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (!called) {
            called = true;
            fn.apply(void 0, args);
        }
    };
}
exports.once = once;

},{}],5:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable consistent-return */
function promiseOrCallback(promise, callback) {
    if (!callback) {
        return promise;
    }
    promise.then(function (data) { return callback(null, data); }).catch(function (err) { return callback(err); });
}
exports.promiseOrCallback = promiseOrCallback;

},{}],6:[function(_dereq_,module,exports){
"use strict";
var deferred_1 = _dereq_("./lib/deferred");
var once_1 = _dereq_("./lib/once");
var promise_or_callback_1 = _dereq_("./lib/promise-or-callback");
function wrapPromise(fn) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var callback;
        var lastArg = args[args.length - 1];
        if (typeof lastArg === "function") {
            callback = args.pop();
            callback = once_1.once(deferred_1.deferred(callback));
        }
        // I know, I know, this looks bad. But it's a quirk of the library that
        // we need to allow passing the this context to the original function
        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
        // @ts-ignore: this has an implicit any
        return promise_or_callback_1.promiseOrCallback(fn.apply(this, args), callback); // eslint-disable-line no-invalid-this
    };
}
wrapPromise.wrapPrototype = function (target, options) {
    if (options === void 0) { options = {}; }
    var ignoreMethods = options.ignoreMethods || [];
    var includePrivateMethods = options.transformPrivateMethods === true;
    var methods = Object.getOwnPropertyNames(target.prototype).filter(function (method) {
        var isNotPrivateMethod;
        var isNonConstructorFunction = method !== "constructor" &&
            typeof target.prototype[method] === "function";
        var isNotAnIgnoredMethod = ignoreMethods.indexOf(method) === -1;
        if (includePrivateMethods) {
            isNotPrivateMethod = true;
        }
        else {
            isNotPrivateMethod = method.charAt(0) !== "_";
        }
        return (isNonConstructorFunction && isNotPrivateMethod && isNotAnIgnoredMethod);
    });
    methods.forEach(function (method) {
        var original = target.prototype[method];
        target.prototype[method] = wrapPromise(original);
    });
    return target;
};
module.exports = wrapPromise;

},{"./lib/deferred":3,"./lib/once":4,"./lib/promise-or-callback":5}],7:[function(_dereq_,module,exports){
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.loadAxo = {}));
})(this, (function (exports) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */


    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    var dist = {};

    var scriptPromiseCache = {};
    function loadScript$1(options) {
        var scriptLoadPromise;
        var stringifiedOptions = JSON.stringify(options);
        if (!options.forceScriptReload) {
            scriptLoadPromise = scriptPromiseCache[stringifiedOptions];
            if (scriptLoadPromise) {
                return scriptLoadPromise;
            }
        }
        var script = document.createElement("script");
        var attrs = options.dataAttributes || {};
        var container = options.container || document.head;
        script.src = options.src;
        script.id = options.id || "";
        script.async = true;
        if (options.type) {
            script.setAttribute("type", "".concat(options.type));
        }
        if (options.crossorigin) {
            script.setAttribute("crossorigin", "".concat(options.crossorigin));
        }
        Object.keys(attrs).forEach(function (key) {
            script.setAttribute("data-".concat(key), "".concat(attrs[key]));
        });
        scriptLoadPromise = new Promise(function (resolve, reject) {
            script.addEventListener("load", function () {
                resolve(script);
            });
            script.addEventListener("error", function () {
                reject(new Error("".concat(options.src, " failed to load.")));
            });
            script.addEventListener("abort", function () {
                reject(new Error("".concat(options.src, " has aborted.")));
            });
            container.appendChild(script);
        });
        scriptPromiseCache[stringifiedOptions] = scriptLoadPromise;
        return scriptLoadPromise;
    }
    loadScript$1.clearCache = function () {
        scriptPromiseCache = {};
    };
    var loadScript_1$1 = loadScript$1;

    var loadStylesheet$1 = function loadStylesheet(options) {
        var stylesheet = document.querySelector("link[href=\"".concat(options.href, "\"]"));
        if (stylesheet) {
            return Promise.resolve(stylesheet);
        }
        stylesheet = document.createElement("link");
        var container = options.container || document.head;
        stylesheet.setAttribute("rel", "stylesheet");
        stylesheet.setAttribute("type", "text/css");
        stylesheet.setAttribute("href", options.href);
        stylesheet.setAttribute("id", options.id);
        if (container.firstChild) {
            container.insertBefore(stylesheet, container.firstChild);
        }
        else {
            container.appendChild(stylesheet);
        }
        return Promise.resolve(stylesheet);
    };

    Object.defineProperty(dist, "__esModule", { value: true });
    dist.loadStylesheet = loadScript_1 = dist.loadScript = void 0;
    var loadScript = loadScript_1$1;
    var loadScript_1 = dist.loadScript = loadScript;
    var loadStylesheet = loadStylesheet$1;
    dist.loadStylesheet = loadStylesheet;

    var CDNX_PROD = "https://www.paypalobjects.com";
    var ASSET_NAME = {
        minified: "axo.min",
        unminified: "axo",
    };
    var FL_NAMESPACE = "fastlane";
    var ASSET_PATH = "connect-boba";
    var LOCALE_PATH = "".concat(ASSET_PATH, "/locales/");
    var constants = {
        AXO_ASSET_NAME: ASSET_NAME,
        AXO_ASSET_PATH: ASSET_PATH,
        LOCALE_PATH: LOCALE_PATH,
        CDNX_PROD: CDNX_PROD,
    };

    var AxoSupportedPlatforms = {
        BT: "BT",
        PPCP: "PPCP",
    };

    /**
     * Checks if the current environment is an AMD environment.
     *
     * @returns {boolean} True if the environment is AMD, false otherwise.
     */
    function isAmdEnv() {
        return typeof window.define === "function" && !!window.define.amd;
    }
    /**
     * Checks if the current environment is a RequireJS environment.
     *
     * @returns {boolean} True if the environment is RequireJS, false otherwise.
     */
    function isRequireJsEnv() {
        return (isAmdEnv() &&
            typeof window.requirejs === "function" &&
            typeof window.requirejs.config === "function");
    }

    /**
     * Safely loads BT modules by checking if the module already exists and verifying if versions mismatch
     *
     * @param loadConfig <BtModuleLoadConfig> Configuration of BT Module to load
     * @param version <string> version that should be passed from the client getVersion
     * @returns Promise<HTMLScriptElement>
     * @returns Promise<true> when BT module with same version already exists
     * @returns Promise.reject(err) when BT module already exists but versions mismatch or empty version passed in
     */
    function safeLoadBtModule(loadConfig, version, minified) {
        var _a, _b;
        if (minified === void 0) { minified = true; }
        return __awaiter(this, void 0, void 0, function () {
            var bt, existingVersion;
            return __generator(this, function (_c) {
                bt = getBraintree();
                if (bt && bt[loadConfig.module]) {
                    if (version && ((_a = bt[loadConfig.module]) === null || _a === void 0 ? void 0 : _a.VERSION) !== version) {
                        existingVersion = (_b = bt[loadConfig.module]) === null || _b === void 0 ? void 0 : _b.VERSION;
                        throw new Error("".concat(loadConfig.module, " already loaded with version ").concat(existingVersion, " cannot load version ").concat(version));
                    }
                    else {
                        return [2 /*return*/, true];
                    }
                }
                if (!version) {
                    throw new Error("Attempted to load ".concat(loadConfig.module, " without specifying version"));
                }
                return [2 /*return*/, loadBtModule(loadConfig, version, minified)];
            });
        });
    }
    /**
     * Reads the version and to load the correct version of Bt module
     *
     * @param loadConfig <BtModuleLoadConfig> Configuration of BT Module to load
     * @param version <string> Bt module version
     * @returns Promise<HTMLScriptElement> or
     */
    function loadBtModule(loadConfig, version, minified) {
        if (minified === void 0) { minified = true; }
        if (isAmdEnv()) {
            var module_1 = minified
                ? loadConfig.amdModule.minified
                : loadConfig.amdModule.unminified;
            return new Promise(function (resolve, reject) {
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                window.require([module_1], resolve, reject);
            });
        }
        var script = minified
            ? loadConfig.script.minified
            : loadConfig.script.unminified;
        return loadScript_1({
            id: "".concat(loadConfig.id, "-").concat(version),
            src: "https://js.braintreegateway.com/web/".concat(version, "/js/").concat(script),
        });
    }
    /**
     * Looks for the Braintree web sdk on the window object
     *
     * @returns Braintree web sdk
     */
    function getBraintree() {
        return window === null || window === void 0 ? void 0 : window.braintree;
    }

    var _a, _b;
    /**
     * Maps to the BT module namespace created on the window.braintree object
     */
    var BtModule = {
        Client: "client",
        HostedCardFields: "hostedFields",
    };
    var BT_NAMESPACE = "braintree";
    var BT_ASSET_NAME = (_a = {},
        _a[BtModule.Client] = "client",
        _a[BtModule.HostedCardFields] = "hosted-fields",
        _a);
    var btModulesLoadConfig = (_b = {},
        _b[BtModule.Client] = {
            id: "client",
            module: BtModule.Client,
            amdModule: {
                unminified: "".concat(BT_NAMESPACE, "/").concat(BT_ASSET_NAME[BtModule.Client]),
                minified: "".concat(BT_NAMESPACE, "/").concat(BT_ASSET_NAME[BtModule.Client], ".min"),
            },
            script: {
                unminified: "".concat(BT_ASSET_NAME[BtModule.Client], ".js"),
                minified: "".concat(BT_ASSET_NAME[BtModule.Client], ".min.js"),
            },
        },
        _b[BtModule.HostedCardFields] = {
            id: "hcf",
            module: BtModule.HostedCardFields,
            amdModule: {
                unminified: "".concat(BT_NAMESPACE, "/").concat(BT_ASSET_NAME[BtModule.HostedCardFields]),
                minified: "".concat(BT_NAMESPACE, "/").concat(BT_ASSET_NAME[BtModule.HostedCardFields], ".min"),
            },
            script: {
                unminified: "".concat(BT_ASSET_NAME[BtModule.HostedCardFields], ".js"),
                minified: "".concat(BT_ASSET_NAME[BtModule.HostedCardFields], ".min.js"),
            },
        },
        _b);

    /**
     * Loads accelerated checkout components.
     * @param options object with a minified parameter to determine if the script that is loaded should be minified or not (defaults to true if)
     * @returns an object with metadata with a localeUrl parameter to be read by AXO SDK
     */
    function loadAxo(options) {
        return __awaiter(this, void 0, void 0, function () {
            var btSdkVersion, minified, assetUrl, localeUrl;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        performance.mark("pp_axo_sdk_init_invoked");
                        btSdkVersion = options.btSdkVersion, minified = options.minified;
                        assetUrl = getAssetsUrl(options);
                        localeUrl = getLocaleUrl(options);
                        if (!(options.platform === AxoSupportedPlatforms.BT)) return [3 /*break*/, 2];
                        return [4 /*yield*/, Promise.all([
                                safeLoadBtModule(btModulesLoadConfig.hostedFields, btSdkVersion, minified),
                                loadAXOScript(assetUrl, minified),
                            ])];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 5];
                    case 2:
                        if (!(options.platform === AxoSupportedPlatforms.PPCP)) return [3 /*break*/, 4];
                        return [4 /*yield*/, Promise.all([
                                safeLoadBtModule(btModulesLoadConfig.client, btSdkVersion, minified),
                                safeLoadBtModule(btModulesLoadConfig.hostedFields, btSdkVersion, minified),
                                loadAXOScript(assetUrl, minified),
                            ])];
                    case 3:
                        _a.sent();
                        return [3 /*break*/, 5];
                    case 4: throw new Error("unsupported axo platform");
                    case 5: return [2 /*return*/, { metadata: { localeUrl: localeUrl } }];
                }
            });
        });
    }
    /**
     * Reads the url and to load the axo bundle script
     * @param url (Required) string url for the correct axo asset
     * @returns Promise<HTMLScriptElement>
     */
    function loadAXOScript(url, minified) {
        var _a;
        if (minified === void 0) { minified = true; }
        if (isAmdEnv()) {
            // AMD environment
            if (isRequireJsEnv()) {
                // Let's configure RequireJS
                requirejs.config({
                    paths: (_a = {},
                        _a[FL_NAMESPACE] = url,
                        _a),
                });
            }
            var moduleName_1 = "".concat(FL_NAMESPACE, "/").concat(minified
                ? constants.AXO_ASSET_NAME.minified
                : constants.AXO_ASSET_NAME.unminified);
            return new Promise(function (resolve, reject) {
                window.require([moduleName_1], resolve, reject);
            });
        }
        // Not an AMD environment
        return loadScript_1({
            id: "axo-id",
            src: url,
            forceScriptReload: true,
        });
    }
    /**
     * Prepends the domain to the asset url
     * @param options object with assetUrl and bundleid parameters to determine which URL to return
     * @returns full domain and assets URL as string
     */
    function generateAssetUrl(_a) {
        var assetUrl = _a.assetUrl, bundleId = _a.bundleId;
        return bundleId
            ? "https://cdn-".concat(bundleId, ".static.engineering.dev.paypalinc.com/").concat(assetUrl)
            : "".concat(constants.CDNX_PROD, "/").concat(assetUrl);
    }
    /**
     * Retrieves either the minified or unminified assets URL as specified
     * @param options (Optional) object with a minified and metadata with bundleIdOverride parameters to determine which URL to return
     * @returns assets URL as string
     */
    function getAssetsUrl(options) {
        var _a;
        var assetName = (options === null || options === void 0 ? void 0 : options.minified) !== false
            ? constants.AXO_ASSET_NAME.minified
            : constants.AXO_ASSET_NAME.unminified;
        var assetUrl = isAmdEnv()
            ? constants.AXO_ASSET_PATH
            : "".concat(constants.AXO_ASSET_PATH, "/").concat(assetName, ".js");
        return generateAssetUrl({
            assetUrl: assetUrl,
            bundleId: (_a = options === null || options === void 0 ? void 0 : options.metadata) === null || _a === void 0 ? void 0 : _a.bundleIdOverride,
        });
    }
    /**
     * Retrieves the Locales URL, the path to our language files
     * @param options (Optional) object with a minified and metadata with bundleIdOverride parameters to determine which URL to return
     * @returns locale URL as string
     */
    function getLocaleUrl(options) {
        var _a;
        return generateAssetUrl({
            assetUrl: constants.LOCALE_PATH,
            bundleId: (_a = options === null || options === void 0 ? void 0 : options.metadata) === null || _a === void 0 ? void 0 : _a.bundleIdOverride,
        });
    }

    exports.constants = constants;
    exports.loadAxo = loadAxo;

}));

},{}],8:[function(_dereq_,module,exports){
"use strict";

var BraintreeError = _dereq_("../lib/braintree-error");
var errors = _dereq_("./errors");
var assign = _dereq_("../lib/assign").assign;
var methods = _dereq_("../lib/methods");
var convertMethodsToError = _dereq_("../lib/convert-methods-to-error");
var wrapPromise = _dereq_("@braintree/wrap-promise");

/**
 * @class
 * @param {object} options Options
 * @description <strong>You cannot use this constructor directly. Use {@link module:braintree-web/american-express.create|braintree.american-express.create} instead.</strong>
 * @classdesc This class allows you use a nonce to interact with American Express Checkout. To accept American Express cards, use Hosted Fields.
 */
function AmericanExpress(options) {
  this._client = options.client;
}

/**
 * Gets the rewards balance associated with a Braintree nonce.
 * @public
 * @param {object} options Request options
 * @param {string} options.nonce An existing Braintree nonce.
 * @param {callback} [callback] The second argument, <code>data</code>, is the returned server data. If no callback is provided, `getRewardsBalance` returns a promise that resolves with the server data.
 * @returns {(Promise|void)} Returns a promise if no callback is provided.
 * @example
 * var americanExpress = require('braintree-web/american-express');
 *
 * americanExpress.create({client: clientInstance}, function (createErr, americanExpressInstance) {
 *   var options = {nonce: existingBraintreeNonce};
 *   americanExpressInstance.getRewardsBalance(options, function (getErr, payload) {
 *     if (getErr || payload.error) {
 *       // Handle error
 *       return;
 *     }
 *
 *     console.log('Rewards amount: ' + payload.rewardsAmount);
 *   });
 * });
 */
AmericanExpress.prototype.getRewardsBalance = function (options) {
  var nonce = options.nonce;
  var data;

  if (!nonce) {
    return Promise.reject(
      new BraintreeError({
        type: errors.AMEX_NONCE_REQUIRED.type,
        code: errors.AMEX_NONCE_REQUIRED.code,
        message: "getRewardsBalance must be called with a nonce.",
      })
    );
  }

  data = assign(
    {
      _meta: { source: "american-express" },
      paymentMethodNonce: nonce,
    },
    options
  );

  delete data.nonce;

  return this._client
    .request({
      method: "get",
      endpoint: "payment_methods/amex_rewards_balance",
      data: data,
    })
    .catch(function (err) {
      return Promise.reject(
        new BraintreeError({
          type: errors.AMEX_NETWORK_ERROR.type,
          code: errors.AMEX_NETWORK_ERROR.code,
          message:
            "A network error occurred when getting the American Express rewards balance.",
          details: {
            originalError: err,
          },
        })
      );
    });
};

/**
 * Gets the Express Checkout nonce profile given a nonce from American Express.
 * @public
 * @param {object} options Request options
 * @param {string} options.nonce An existing nonce from American Express (note that this is <em>not</em> a nonce from Braintree).
 * @param {callback} [callback] The second argument, <code>data</code>, is the returned server data. If no callback is provided, `getExpressCheckoutProfile` returns a promise that resolves with the server data.
 * @returns {(Promise|void)} Returns a promise if no callback is provided.
 * @example
 * var americanExpress = require('braintree-web/american-express');
 *
 * americanExpress.create({client: clientInstance}, function (createErr, americanExpressInstance) {
 *   var options = {nonce: existingAmericanExpressNonce};
 *   americanExpressInstance.getExpressCheckoutProfile(options, function (getErr, payload) {
 *     if (getErr) {
 *       // Handle error
 *       return;
 *     }
 *
 *     console.log('Number of cards: ' + payload.amexExpressCheckoutCards.length);
 *   });
 * });
 */
AmericanExpress.prototype.getExpressCheckoutProfile = function (options) {
  if (!options.nonce) {
    return Promise.reject(
      new BraintreeError({
        type: errors.AMEX_NONCE_REQUIRED.type,
        code: errors.AMEX_NONCE_REQUIRED.code,
        message: "getExpressCheckoutProfile must be called with a nonce.",
      })
    );
  }

  return this._client
    .request({
      method: "get",
      endpoint: "payment_methods/amex_express_checkout_cards/" + options.nonce,
      data: {
        _meta: { source: "american-express" },
        paymentMethodNonce: options.nonce,
      },
    })
    .catch(function (err) {
      return Promise.reject(
        new BraintreeError({
          type: errors.AMEX_NETWORK_ERROR.type,
          code: errors.AMEX_NETWORK_ERROR.code,
          message:
            "A network error occurred when getting the American Express Checkout nonce profile.",
          details: {
            originalError: err,
          },
        })
      );
    });
};

/**
 * Cleanly tear down anything set up by {@link module:braintree-web/american-express.create|create}.
 * @public
 * @param {callback} [callback] Called once teardown is complete. No data is returned if teardown completes successfully.
 * @example
 * americanExpressInstance.teardown();
 * @example <caption>With callback</caption>
 * americanExpressInstance.teardown(function () {
 *   // teardown is complete
 * });
 * @returns {(Promise|void)} Returns a promise if no callback is provided.
 */
AmericanExpress.prototype.teardown = function () {
  convertMethodsToError(this, methods(AmericanExpress.prototype));

  return Promise.resolve();
};

module.exports = wrapPromise.wrapPrototype(AmericanExpress);

},{"../lib/assign":12,"../lib/braintree-error":14,"../lib/convert-methods-to-error":16,"../lib/methods":21,"./errors":9,"@braintree/wrap-promise":6}],9:[function(_dereq_,module,exports){
"use strict";

/**
 * @name BraintreeError.American Express - getRewardsBalance Error Codes
 * @description Errors that occur when creating components.
 * @property {MERCHANT} AMEX_NONCE_REQUIRED Occurs when a nonce is not provided to method.
 * @property {NETWORK} AMEX_NETWORK_ERROR Occurs when there is an error communicating with the Braintree gateway.
 */

/**
 * @name BraintreeError.American Express - getExpressCheckoutProfile Error Codes
 * @description Errors that occur when creating components.
 * @property {MERCHANT} AMEX_NONCE_REQUIRED Occurs when a nonce is not provided to method.
 * @property {NETWORK} AMEX_NETWORK_ERROR Occurs when there is an error communicating with the Braintree gateway.
 */

var BraintreeError = _dereq_("../lib/braintree-error");

module.exports = {
  AMEX_NONCE_REQUIRED: {
    type: BraintreeError.types.MERCHANT,
    code: "AMEX_NONCE_REQUIRED",
  },
  AMEX_NETWORK_ERROR: {
    type: BraintreeError.types.NETWORK,
    code: "AMEX_NETWORK_ERROR",
  },
};

},{"../lib/braintree-error":14}],10:[function(_dereq_,module,exports){
"use strict";
/**
 * @module braintree-web/american-express
 * @description This module is for use with Amex Express Checkout. To accept American Express cards, use Hosted Fields.
 */

var AmericanExpress = _dereq_("./american-express");
var basicComponentVerification = _dereq_("../lib/basic-component-verification");
var createDeferredClient = _dereq_("../lib/create-deferred-client");
var createAssetsUrl = _dereq_("../lib/create-assets-url");
var VERSION = "3.115.1";
var wrapPromise = _dereq_("@braintree/wrap-promise");

/**
 * @static
 * @function create
 * @param {object} options Creation options:
 * @param {Client} [options.client] A {@link Client} instance.
 * @param {string} [options.authorization] A tokenizationKey or clientToken. Can be used in place of `options.client`.
 * @param {callback} [callback] The second argument, `data`, is the {@link AmericanExpress} instance. If no callback is provided, `create` returns a promise that resolves with the {@link AmericanExpress} instance.
 * @returns {(Promise|void)} Returns a promise if no callback is provided.
 */
function create(options) {
  var name = "American Express";

  return basicComponentVerification
    .verify({
      name: name,
      client: options.client,
      authorization: options.authorization,
    })
    .then(function () {
      return createDeferredClient.create({
        authorization: options.authorization,
        client: options.client,
        debug: options.debug,
        assetsUrl: createAssetsUrl.create(options.authorization),
        name: name,
      });
    })
    .then(function (client) {
      options.client = client;

      return new AmericanExpress(options);
    });
}

module.exports = {
  create: wrapPromise(create),
  /**
   * @description The current version of the SDK, i.e. `{@pkg version}`.
   * @type {string}
   */
  VERSION: VERSION,
};

},{"../lib/basic-component-verification":13,"../lib/create-assets-url":17,"../lib/create-deferred-client":18,"./american-express":8,"@braintree/wrap-promise":6}],11:[function(_dereq_,module,exports){
"use strict";

var loadScript = _dereq_("@braintree/asset-loader/load-script");
var loadConnectScript = _dereq_("@paypal/accelerated-checkout-loader");

module.exports = {
  loadScript: loadScript,
  loadFastlane: loadConnectScript.loadAxo,
};

},{"@braintree/asset-loader/load-script":2,"@paypal/accelerated-checkout-loader":7}],12:[function(_dereq_,module,exports){
"use strict";

var assignNormalized =
  typeof Object.assign === "function" ? Object.assign : assignPolyfill;

function assignPolyfill(destination) {
  var i, source, key;

  for (i = 1; i < arguments.length; i++) {
    source = arguments[i];
    for (key in source) {
      if (source.hasOwnProperty(key)) {
        destination[key] = source[key];
      }
    }
  }

  return destination;
}

module.exports = {
  assign: assignNormalized,
  _assign: assignPolyfill,
};

},{}],13:[function(_dereq_,module,exports){
"use strict";

var BraintreeError = _dereq_("./braintree-error");
var sharedErrors = _dereq_("./errors");
var VERSION = "3.115.1";

function basicComponentVerification(options) {
  var client, authorization, name;

  if (!options) {
    return Promise.reject(
      new BraintreeError({
        type: sharedErrors.INVALID_USE_OF_INTERNAL_FUNCTION.type,
        code: sharedErrors.INVALID_USE_OF_INTERNAL_FUNCTION.code,
        message:
          "Options must be passed to basicComponentVerification function.",
      })
    );
  }

  name = options.name;
  client = options.client;
  authorization = options.authorization;

  if (!client && !authorization) {
    return Promise.reject(
      new BraintreeError({
        type: sharedErrors.INSTANTIATION_OPTION_REQUIRED.type,
        code: sharedErrors.INSTANTIATION_OPTION_REQUIRED.code,
        // NEXT_MAJOR_VERSION in major version, we expose passing in authorization for all components
        // instead of passing in a client instance. Leave this a silent feature for now.
        message: "options.client is required when instantiating " + name + ".",
      })
    );
  }

  if (!authorization && client.getVersion() !== VERSION) {
    return Promise.reject(
      new BraintreeError({
        type: sharedErrors.INCOMPATIBLE_VERSIONS.type,
        code: sharedErrors.INCOMPATIBLE_VERSIONS.code,
        message:
          "Client (version " +
          client.getVersion() +
          ") and " +
          name +
          " (version " +
          VERSION +
          ") components must be from the same SDK version.",
      })
    );
  }

  return Promise.resolve();
}

module.exports = {
  verify: basicComponentVerification,
};

},{"./braintree-error":14,"./errors":20}],14:[function(_dereq_,module,exports){
"use strict";

var enumerate = _dereq_("./enumerate");

/**
 * @class
 * @global
 * @param {object} options Construction options
 * @classdesc This class is used to report error conditions, frequently as the first parameter to callbacks throughout the Braintree SDK.
 * @description <strong>You cannot use this constructor directly. Interact with instances of this class through {@link callback callbacks}.</strong>
 */
function BraintreeError(options) {
  if (!BraintreeError.types.hasOwnProperty(options.type)) {
    throw new Error(options.type + " is not a valid type.");
  }

  if (!options.code) {
    throw new Error("Error code required.");
  }

  if (!options.message) {
    throw new Error("Error message required.");
  }

  this.name = "BraintreeError";

  /**
   * @type {string}
   * @description A code that corresponds to specific errors.
   */
  this.code = options.code;

  /**
   * @type {string}
   * @description A short description of the error.
   */
  this.message = options.message;

  /**
   * @type {BraintreeError.types}
   * @description The type of error.
   */
  this.type = options.type;

  /**
   * @type {object=}
   * @description Additional information about the error, such as an underlying network error response.
   */
  this.details = options.details;
}

BraintreeError.prototype = Object.create(Error.prototype);
BraintreeError.prototype.constructor = BraintreeError;

/**
 * Enum for {@link BraintreeError} types.
 * @name BraintreeError.types
 * @enum
 * @readonly
 * @memberof BraintreeError
 * @property {string} CUSTOMER An error caused by the customer.
 * @property {string} MERCHANT An error that is actionable by the merchant.
 * @property {string} NETWORK An error due to a network problem.
 * @property {string} INTERNAL An error caused by Braintree code.
 * @property {string} UNKNOWN An error where the origin is unknown.
 */
BraintreeError.types = enumerate([
  "CUSTOMER",
  "MERCHANT",
  "NETWORK",
  "INTERNAL",
  "UNKNOWN",
]);

BraintreeError.findRootError = function (err) {
  if (
    err instanceof BraintreeError &&
    err.details &&
    err.details.originalError
  ) {
    return BraintreeError.findRootError(err.details.originalError);
  }

  return err;
};

module.exports = BraintreeError;

},{"./enumerate":19}],15:[function(_dereq_,module,exports){
"use strict";

var VERSION = "3.115.1";
var PLATFORM = "web";

var CLIENT_API_URLS = {
  production: "https://api.braintreegateway.com:443",
  sandbox: "https://api.sandbox.braintreegateway.com:443",
};

var ASSETS_URLS = {
  production: "https://assets.braintreegateway.com",
  sandbox: "https://assets.braintreegateway.com",
};

var GRAPHQL_URLS = {
  production: "https://payments.braintree-api.com/graphql",
  sandbox: "https://payments.sandbox.braintree-api.com/graphql",
};

// endRemoveIf(production)

module.exports = {
  ANALYTICS_PREFIX: PLATFORM + ".",
  ANALYTICS_REQUEST_TIMEOUT_MS: 2000,
  ANALYTICS_URL: "https://www.paypal.com/xoplatform/logger/api/logger",
  ASSETS_URLS: ASSETS_URLS,
  CLIENT_API_URLS: CLIENT_API_URLS,
  FRAUDNET_SOURCE: "BRAINTREE_SIGNIN",
  FRAUDNET_FNCLS: "fnparams-dede7cc5-15fd-4c75-a9f4-36c430ee3a99",
  FRAUDNET_URL: "https://c.paypal.com/da/r/fb.js",
  BUS_CONFIGURATION_REQUEST_EVENT: "BUS_CONFIGURATION_REQUEST",
  GRAPHQL_URLS: GRAPHQL_URLS,
  INTEGRATION_TIMEOUT_MS: 60000,
  VERSION: VERSION,
  INTEGRATION: "custom",
  SOURCE: "client",
  PLATFORM: PLATFORM,
  BRAINTREE_LIBRARY_VERSION: "braintree/" + PLATFORM + "/" + VERSION,
  ALLOWED_EXTRA_EVENT_FIELDS: ["paypal_context_id"],
};

},{}],16:[function(_dereq_,module,exports){
"use strict";

var BraintreeError = _dereq_("./braintree-error");
var sharedErrors = _dereq_("./errors");

module.exports = function (instance, methodNames) {
  methodNames.forEach(function (methodName) {
    instance[methodName] = function () {
      throw new BraintreeError({
        type: sharedErrors.METHOD_CALLED_AFTER_TEARDOWN.type,
        code: sharedErrors.METHOD_CALLED_AFTER_TEARDOWN.code,
        message: methodName + " cannot be called after teardown.",
      });
    };
  });
};

},{"./braintree-error":14,"./errors":20}],17:[function(_dereq_,module,exports){
"use strict";

// endRemoveIf(production)
var ASSETS_URLS = _dereq_("./constants").ASSETS_URLS;

function createAssetsUrl(authorization) {
  // endRemoveIf(production)

  return ASSETS_URLS.production;
}
/* eslint-enable */

module.exports = {
  create: createAssetsUrl,
};

},{"./constants":15}],18:[function(_dereq_,module,exports){
"use strict";

var BraintreeError = _dereq_("./braintree-error");
var assets = _dereq_("./assets");
var sharedErrors = _dereq_("./errors");

var VERSION = "3.115.1";

function createDeferredClient(options) {
  var promise = Promise.resolve();

  if (options.client) {
    return Promise.resolve(options.client);
  }

  if (!(window.braintree && window.braintree.client)) {
    promise = assets
      .loadScript({
        src: options.assetsUrl + "/web/" + VERSION + "/js/client.min.js",
      })
      .catch(function (err) {
        return Promise.reject(
          new BraintreeError({
            type: sharedErrors.CLIENT_SCRIPT_FAILED_TO_LOAD.type,
            code: sharedErrors.CLIENT_SCRIPT_FAILED_TO_LOAD.code,
            message: sharedErrors.CLIENT_SCRIPT_FAILED_TO_LOAD.message,
            details: {
              originalError: err,
            },
          })
        );
      });
  }

  return promise.then(function () {
    if (window.braintree.client.VERSION !== VERSION) {
      return Promise.reject(
        new BraintreeError({
          type: sharedErrors.INCOMPATIBLE_VERSIONS.type,
          code: sharedErrors.INCOMPATIBLE_VERSIONS.code,
          message:
            "Client (version " +
            window.braintree.client.VERSION +
            ") and " +
            options.name +
            " (version " +
            VERSION +
            ") components must be from the same SDK version.",
        })
      );
    }

    return window.braintree.client.create({
      authorization: options.authorization,
      debug: options.debug,
    });
  });
}

module.exports = {
  create: createDeferredClient,
};

},{"./assets":11,"./braintree-error":14,"./errors":20}],19:[function(_dereq_,module,exports){
"use strict";

function enumerate(values, prefix) {
  prefix = prefix == null ? "" : prefix;

  return values.reduce(function (enumeration, value) {
    enumeration[value] = prefix + value;

    return enumeration;
  }, {});
}

module.exports = enumerate;

},{}],20:[function(_dereq_,module,exports){
"use strict";

/**
 * @name BraintreeError.Shared Internal Error Codes
 * @ignore
 * @description These codes should never be experienced by the merchant directly.
 * @property {INTERNAL} INVALID_USE_OF_INTERNAL_FUNCTION Occurs when the client is created without a gateway configuration. Should never happen.
 */

/**
 * @name BraintreeError.Shared Errors - Component Creation Error Codes
 * @description Errors that occur when creating components.
 * @property {MERCHANT} INSTANTIATION_OPTION_REQUIRED Occurs when a component is created that is missing a required option.
 * @property {MERCHANT} INCOMPATIBLE_VERSIONS Occurs when a component is created with a client with a different version than the component.
 * @property {NETWORK} CLIENT_SCRIPT_FAILED_TO_LOAD Occurs when a component attempts to load the Braintree client script, but the request fails.
 */

/**
 * @name BraintreeError.Shared Errors - Component Instance Error Codes
 * @description Errors that occur when using instances of components.
 * @property {MERCHANT} METHOD_CALLED_AFTER_TEARDOWN Occurs when a method is called on a component instance after it has been torn down.
 */

var BraintreeError = _dereq_("./braintree-error");

module.exports = {
  INVALID_USE_OF_INTERNAL_FUNCTION: {
    type: BraintreeError.types.INTERNAL,
    code: "INVALID_USE_OF_INTERNAL_FUNCTION",
  },
  INSTANTIATION_OPTION_REQUIRED: {
    type: BraintreeError.types.MERCHANT,
    code: "INSTANTIATION_OPTION_REQUIRED",
  },
  INCOMPATIBLE_VERSIONS: {
    type: BraintreeError.types.MERCHANT,
    code: "INCOMPATIBLE_VERSIONS",
  },
  CLIENT_SCRIPT_FAILED_TO_LOAD: {
    type: BraintreeError.types.NETWORK,
    code: "CLIENT_SCRIPT_FAILED_TO_LOAD",
    message: "Braintree client script could not be loaded.",
  },
  METHOD_CALLED_AFTER_TEARDOWN: {
    type: BraintreeError.types.MERCHANT,
    code: "METHOD_CALLED_AFTER_TEARDOWN",
  },
};

},{"./braintree-error":14}],21:[function(_dereq_,module,exports){
"use strict";

module.exports = function (obj) {
  return Object.keys(obj).filter(function (key) {
    return typeof obj[key] === "function";
  });
};

},{}]},{},[10])(10)
});
